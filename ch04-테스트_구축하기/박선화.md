# 4장 테스트 구축하기

리펙터링을 제대로 하려면 견고한 테스트 스위트가 뒷받침돼야 한다.

실제로는 코드 작성, 버그 수정보다 디버깅에 대부분의 시간을 쓴다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 테스트를 작성하면서 원하는 기능을 추가히기 위해 무엇이 필요한지 고민하게 된다. 켄트백은 이를 바탕으로 테스트 주도 개발 기법을 창시했다.

## 테스트 예시

모카 프레임워크를 사용하여 단위 테스트를 수행한다.

모카 프레임워크는 테스트 코드를 블록 단위로 나눠서 각 블록에 테스트 스위트를 담는 구조다. 테스트는 it 블록에 담긴다.

1. 첫 번째 단계에서는 테스트에 필요한 데이터와 객체를 뜻하는 픽스처(fixture)를 설정한다.
2. 두 번째 단계에서는 이 픽스처의 속성들을 검증한다. 여기서는 주어진 초깃값에 기초하여 정확히 계산되었는지를 확인한다.

실전에서 테스트 수는 수천 개 이상일 수 있다. 따라서 간결한 피드백은 매우 중요하다. 방금 추가한 코드에 문제가 없는지, 리팩터링한 코드에 문제가 없는지 자주 테스트 한다.

## 테스트 추가하기

테스트는 위험 요인을 중심으로 작성해야 한다. 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는 데 있다.

잘못될까 걱정되는 영역을 집중적으로 테스트하면, 테스트에 쏟는 노력의 효과를 극대화할 수 있다.

### 공유 픽스처 피하기

테스트끼리 상호작용하게 하는 공유 픽스처는 테스트 관련 버그의 원인이 된다.

```javascript
describe('province', function () {
  const asia = new Province(sampleProvinceData()) // ❌ -> 공유 픽스처는 버그의 원인이 된다.

  it('shortfall', function () {
    expect(asia.shortfall).toBe(5)
  })

  it('profit', function () {
    expect(asia.profit).toBe(230)
  })
})
```

나중에 다른 테스트에서 공유 객체의 값을 수정하면 해당 픽스처를 사용하는 또 다른 테스트가 실패할 수 있다.

```javascript
describe('province', function () {
  let asia
  beforeEach(function () {
    // ✅
    asia = new Province(sampleProvinceData())
  })

  it('shortfall', function () {
    expect(asia.shortfall).toBe(5)
  })

  it('profit', function () {
    expect(asia.profit).toBe(230)
  })
})
```

beforeEach 구문은 각각의 테스트 바로 전에 실행되어 asia를 초기화하기 때문에 모든 테스트가 자신만의 새로운 asia를 사용하게 된다.
이처럼 개별 테스트를 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있어서, 결과를 예측할 수 없는 상황을 예방할 수 있다.

각 코드를 각각의 it 블록에 넣는 것보다, beforeEach를 사용하면 모든 테스트들이 모두 같은 픽스처에 기초하여 검증을 수행함을 보장할 수 있다.

## 픽스처 수정하기

픽스처의 수정하는 대부분의 경우 세터에서 이뤄진다. 보통 세터는 단순해서 잘 테스트하지 않는다. 복잡한 세터의 경우 테스트해볼 필요가 있다.

```javascript
describe('province', function () {
  let asia
  beforeEach(function () {
    asia = new Province(sampleProvinceData())
  })

  ...

  it('change production', function () {
    asia.producers[0].production = 20
    expect(asia.shortfall).toBe(-6)
    expect(asia.profit).toBe(292)
  })
})
```

beforeEach 블록에서 '설정'한 표준 픽스처를 취해서, 테스트를 '수행'하고, 이 픽스처가 일을 기대한 대로 처리했는지를 '검증'한다.
이러한 패턴을 설정-실행-검증, 조건-발생-결과, 준비-수행-단언 등으로 부른다. 이 세 가지 단계가 한 테스트 안에 모두 담겨 있을 수도 있고, 초기 준비 작업 중 공통되는 부분을 beforeEach와 같은 표준 설정 루틴에 모아서 처리하기도 한다.

## 경계 조건 검사하기

숫자형의 경우 0 또는 음수, 컬렉션의 경우 해당 컬렉션이 비어있는 케이스 등의 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.

테스트를 어느 수준까지 해야 할까? 버그 없는 완변한 프로그램은 없겠지만 테스트가 프로그래밍 속도를 높여준다는 사실에는 변함이 없다. 프로그램에서 발생할 수 있는 모든 경우를 테스트하기 위한 기법이 도움되는 것은 분명하지만, 너무 빠져들 필요는 없다. 테스트에도 수확 체감 법칙이 적용된다. 테스트를 위험한 부분에 집중하는 게 좋다. 코드에서 처리 과정이 복잡한 부분을 찾아보자. 테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩터링할 수 있는 보호막은 되어준다.

## 단위 테스트

이 장에서 보여준 테스트는 단위 테스트에 해당한다. 단위 테스트란 코드의 작은 영역만을 대상으로 빠르게 실행되도록 설계된 테스트다.
단위 테스트는 자가 테스트 코드의 핵심이자, 자가 테스트 시스템은 대부분 단위 테스트가 차지한다. 물론 컴포넌트 사이의 상호작용에 집중하는 테스트나, 소프트웨어의 다양한 계층의 연동을 검사하는 테스트, 성능 문제를 다루는 테스트 등 다양한 유형의 테스트가 있다.

다른 프로그래밍 활동과 마찬가지로 테스트도 반복적으로 진행한다. 테스트 스위트도 지속해서 보강한다. 다시 말해 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다. 기존 테스트가 충분히 명확한지, 테스트 과정을 더 이해하기 쉽게 리팩터링할 수는 없는지, 제대로 검사하는지 등을 확인한다.

버그를 발견하는 즉시 발견한 버그를 명확히 잡아내는 테스트부터 작성하는 습관을 들이자.

충분한 테스트의 기준을 테스트 커버리지를 기준으로 삼는 사람도 있지만, 테스트 커버리지 분석은 코드에서 테스트하지 않은 영역을 찾는 데만 도움될 뿐, 테스트 스위트의 품질과는 크게 상관없다.

테스트 스위트가 충분한지를 평가하는 기준은 주관적이다. 하지만 자가 테스트 코드의 목적은 이 믿음을 갖게 해주는 것이다.

테스트를 너무 많이 작성할 가능성도 있다. 제품 코드보다 테스트 코드를 수정하는 데 시간이 더 걸린다면, 테스트 코드 때문에 개발 속도가 느려진다고 생각되면 테스트를 과하게 작성한건 아닌지 의심해보자.
