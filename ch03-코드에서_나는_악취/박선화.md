# 3장 코드에서 나는 악취

### 기이한 이름

이름ㅁ만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.

이름은 문맥을 빠르게 파악할 수 있게 해준다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

### 중복 코드

중복된 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다. 그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하면 함수 추출하기로 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.
- 코드가 비슷하지만 완전히 같지는 않다면, 먼저 문장 슬라이드하기로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.
- 같은 부모로부터 파생된 서브 클래스에 코드가 중복된다면 메서드 올리기를 적용해 부모로 옮긴다.

### 긴 함수

예전 언어는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸다. 하지만 요즘 언어는 프로세스 안에서 함수 호출 비용을 거의 없애버렸다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 된다. 이는 개발 환경을 활용하면 부담이 들어줄며, 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 함수를 쪼개야 한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다. 이렇게 함수로 묶는 코드는 여러 줄일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다.

함수를 짧게 만드는 작업의 99%는 함수 추출하기가 차지한다. 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

함수가 매개변수와 임시 변수를 많이 사용하면 추출 작업에 방해가 된다. 그렇다면 임시 변수를 질으 ㅣ함수로 바꾸기로 임시 변수의 수를, 매개변수 객체 만들기와 객체 통째로 넘기기로는 매개변수의 수를 줄일 수 있을 것이다.

그럼에도 여전히 임시 변수와 매개변수가 너무 많다면 함ㅁ수를 명령으로 바꾸기를 고려해보자.

조건문은 조건문 분해하기, switch문은 case문마다 함수 추출하기를 적용하여 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 조건부 로직을 다형성으로 바꾸기를 적용한다.

반복문도 안의 코드와 함께 추출해서 독립된 함수로 만들고, 성격이 다른 작업이 섞여 있다면 반복문 쪼개기를 적용한다.

### 긴 매개변수 목록

과거에는 전역 변수를 막기위해 함수에 모조리 매개변수로 전달했다. 하짐만 매개변수 목록이 길어지면 이해하기가 어려울 때가 많다.

- 다른 매개변수에서 값을 얻을 수 있는 경우는 매개변수를 질의 함수로 바꾸기로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각의 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기를 적용해서 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 매개변수 객체 만들기로 묶어버린다.
- 함수의 동작 방식을 정하는 플래그 역할의 개새변수는 플래그 인수 제거하기로 없애준다.

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 융용하다. 이럴 때는 여러 함수를 클래스로 묶기를 이용하여 공통 값들을 클래스의 필드로 정의한다. 함수형 프로그래밍이었다면 일련의 부분적용 함수들을 생성한다.(커링 함수의 순차적 호출)

### 전역 데이터

전역 데이터는 코드베이스 어디서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다. 이를 방지하기 위해 변수 캡슐화하기를 사용할 수 있다. 데이터를 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다. 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

### 가변 데이터

데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다. 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동하고, 이 문제가 드물게 발생한담면 원인 파악이 힘들다. 무분별한 데이터 수정에 따른 위허을 줄이는 방법들이 있다.

- 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 변수 쪼개기를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
- 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 그러기 위해 문장 슬라이드하기와 함수 추출하기를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- API를 만들 때는 질의 함수와 변경 함수 분리하기를 활용해서 꼭 필요한 경우가 아니라ㅕㄴ 부작용이 있는 코드를 호출할 수 없게 한다.
- 우리는 가능한 한 세터 제거하기도 적용한다. 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범ㅁ위를 줄이는 데 도움될 때가 있다.
- 여러 함수를 클래스로 묶기나 여러 함수를 변환 함수로 묶기를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 , 일반적으로 참조를 값으로 바꾸기를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

### 뒤엉킨 변경

코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.

뒤엉킨 변경은 단일 책이 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다(단계 쪼개기). 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다(함수 옮기기). 그러면 처리 과정이 맥락별로 구분된다. 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 함수 추출하기 부터 수행한다.

### 산탄총 수술

변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다. 이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기를 적용한다. 데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환 함수로 묶기를 적용한다.

어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다. 메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수도 있다. 작은 함수와 클래스가 좋지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는 데 개의치 않는다.

### 기능 편애

프로그램을 모둘화할 때는 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다. 데이터와 친한 함수는 데이터 근처로 함수 옮기기, 때로는 함수 일부에서만 기능을 편애한다면 그 부분만 독립 함수로 함수 추출하기를 통해 원하는 모듈로 보내준다.

어디로 옮길지 명확하게 드러나지 않는 경우 함수 추출하기로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

### 데이터 뭉치

필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다.
메서드 시그니처에 데이터 뭉치가 잇으면, 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해서 매개변수 수를 줄여본다.

### 기본형 집착

- 기본경을 객체로 바꾸기
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 타입 코드를 서브클래스로 바구기와 조건부 로직을 다형성으로 바꾸기를 차례로 적용한다.
- 자주 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 클래스 추출하기와 매개변수 객체 만들기를 이용하면 좋다.

### 반복문

지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다. 필터나 맵같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

### 클래스

거대한 클래스는 클래스 추출하기로 필드들 일부를 따로 묶는다.

같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들은 같은 컴포넌트에 두는 것이 좋을 것이다. 이와 같이 분리할 컴포넌트들을 원래 클래스와 상속 관계로 만드는 게 좋다면 (클래스 추출하기 보다는) 슈퍼클래스 추출하기나 타입 코드를 서브클래스로 바꾸기를 적용하는 편이 더 쉬울 것이다.

클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용한다면 클래스 추출하기. 슈퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기 등을 활용해서 여러 클래스로 분리한다.

### 주석

주석을 달면 안된다고 말하는 것이 아니다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 함수 추출하기를 적용해 본다.
- 이미 추출되어 있는 하수임에도 여전히 서령이 필요하다면 함수 선언 바꾸기로 함수 이름을 바꿔본다.
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 어셔션 추가하기가 대기하고 있다.

뭘 할지 모를 때라면 주석을 달아두면 좋다. 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석에 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다.
