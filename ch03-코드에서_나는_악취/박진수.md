# 코드에서 나는 악취

- 리팩터링 멈추는 시점은 숙련된 사람의 직관만큼 정확한 기준은 없다.
- 리팩터링 문제의 징후를 확인하는 것이 중요.

## 기이한 이름

- 함수, 변수 이름은 최대한 간결하고 명확하게.
- 만약 이름이 길어진다면, 설계에 근본적인 문제가 있는 것일 수도 있다.

## 중복 코드

- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우, 함수 추출하기(6.1절)를 사용.
- 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 문장 슬라이드(8.6절) 사용.

## 긴 함수

- 함수를 짧게 구성해줘야 한다.
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것.
- 주석이 달려있는 코드가 있다면, 오히려 해당 코드들을 함수로 만들고 이름을 주석 내용 토대로 짓자.

## 긴 매개변수 목록

- 매겨변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을때는, 매개변수를 질의함수로 바꾸기(11.5절)로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기는것이 좋다.
- 항상 함께 전달되는 매개변수들은 매개변수 객체 만들기(6.8절)로 하나로 묶어버린다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기(11.3절)로 없애준다.

## 전역 데이터

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없는게 문제다.
- 그래서 유령같은 원격작용처럼, 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾기가 힘들다.
- 전역 데이터가 아주 조금만 있더라도 캡슐화를 한다.

## 가변 데이터

- 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.

## 기능 편애

- 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.

## 데이터 뭉치

- 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해서 매개변수 수를 줄여본다.
- 객체에서 몇개만 뽑아써더라도 걱정할 필요 없다. 새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문.

## 기본형 집착

- 특정 ISO 문자열이나 정수가 아닌 부동소수점 수 같은 데이터를 표현할 때 단순히 원시타입으로 선언한느 것은 위험.
- 차라리 타입을 따로 정의를 하던지, 타입 코드를 서브클래스로 바꾸기(12.6절)와 조건부 로직을 다형성으로 바꾸기(10.4절)를 차례로 적용한다.

## 반복문

- 필터나 맵 같은 파이프라인 연산을 사용하는것이 좋다. 그냥 if문은 안된다.

## 추측성 일반화

- '나중에 필요할거야'라는 생각으로 지금 당장 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성하면 나중에 관리가 힘들어진다.
