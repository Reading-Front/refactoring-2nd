# Chapter 03: Bad Smells in Code  
*“코드 품질을 떨어뜨리는 징후(스멜)를 인식하고 리팩토링이 필요한 지점을 파악하자”*

## 📖 목차  
1. 왜 ‘나쁜 냄새(bad smell)’인가  
2. 주요 코드 스멜 목록  
   - 중복 코드 (Duplicated Code)  
   - 긴 함수 (Long Function)  
   - 긴 매개변수 목록 (Long Parameter List)  
   - 전역 데이터 (Global Data)  
   - 변경이 자주 발생하는 클래스 (Divergent Change)  
   - 샷건 수술 (Shotgun Surgery)  
   - 피처 탐욕 (Feature Envy)  
   - 데이터 뭉치 (Data Clumps)  
   - 원시 값 집착 (Primitive Obsession)  
   - 반복하는 스위치문 (Repeated Switches)  
   - 루프 (Loops)  
   - 게으른 클래스 (Lazy Class)  
   - 추측 일반화 (Speculative Generality)  
   - 임시 필드 (Temporary Field)  
   - 메세지 체인 (Message Chains)  
   - 중개자 클래스 (Middle Man)  
   - 내부 거래 (Inappropriate Intimacy)  
   - 인터페이스가 다른 대안 클래스들 (Alternative Classes with Different Interfaces)  
   - 데이터 클래스 (Data Class)  
   - 거부된 유산 (Refused Bequest)  
   - 주석으로 덮인 코드 (Comments)  
3. 어떻게 이 스멜을 인식하고 대응할 것인가  
4. 요약

## 1. 왜 ‘나쁜 냄새(bad smell)’인가  
- ‘스멜’이란 코드 내부 설계나 구조가 무너지고 있을 가능성을 알려주는 **징후(sign)** 이다. :contentReference[oaicite:1]{index=1}  
- 스멜이 있다는 것은 즉각 리팩토링이 필요하다는 말이 아니라, “이 지점을 좀 더 들여다보면 문제 될 수 있다”는 신호이다. :contentReference[oaicite:2]{index=2}  
- 예를 들어, 동일한 로직이 여러 곳에 복사되어 있다면 하나를 변경할 때 다른 부분도 변경해야 할 가능성이 높아지고, 이는 유지보수 비용 증가로 이어진다. :contentReference[oaicite:3]{index=3}  

---

## 2. 주요 코드 스멜 목록  
아래는 대표적인 코드 스멜들과 TypeScript 예시이다.  
### 중복 코드 (Duplicated Code)  
> 비슷하거나 동일한 코드가 여러 곳에 존재할 때 유지보수 리스크가 높아진다. :contentReference[oaicite:4]{index=4}  
```ts
// 리팩토링 전
function getFinalPrice(quantity: number, price: number): number {
  return quantity * price * 0.9;
}
function getWholesalePrice(quantity: number, price: number): number {
  return quantity * price * 0.8;
}
function getRetailPrice(quantity: number, price: number): number {
  return quantity * price * 1.2;
}

// 리팩토링 후
function calculatePrice(quantity: number, price: number, factor: number): number {
  return quantity * price * factor;
}
const finalPrice = calculatePrice(q, p, 0.9);
const wholesalePrice = calculatePrice(q, p, 0.8);
const retailPrice = calculatePrice(q, p, 1.2);
````

### 긴 함수 (Long Function)

> 한 함수에 너무 많은 책임이 들어 있을 때 이해하기 어렵고 버그가 생기기 쉽다. ([GitHub][1])

```ts
// 리팩토링 전
function processOrder(order: Order) {
  // 유효성 검사
  if (!order.items.length) throw new Error("No items");
  // 가격 계산
  let total = 0;
  for (const item of order.items) {
    total += item.price * item.quantity;
  }
  // 세금 적용
  const tax = total * 0.1;
  total += tax;
  // 출력
  console.log(`Total amount: ${total}`);
}

// 리팩토링 후
function validateOrder(order: Order) {
  if (!order.items.length) throw new Error("No items");
}
function calculateTotal(order: Order): number {
  return order.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}
function applyTax(amount: number): number {
  return amount * 1.1;
}
function printTotal(amount: number) {
  console.log(`Total amount: ${amount}`);
}
function processOrder(order: Order) {
  validateOrder(order);
  const subtotal = calculateTotal(order);
  const total = applyTax(subtotal);
  printTotal(total);
}
```

### 긴 매개변수 목록 (Long Parameter List)

> 매개변수가 많을수록 호출하는 쪽이나 함수 내부 이해가 어려워진다. ([GitHub][1])

```ts
// 리팩토링 전
function createUser(name: string, age: number, email: string, address: string, city: string, country: string) {
  // ...
}

// 리팩토링 후
interface UserInfo {
  name: string;
  age: number;
  email: string;
  address: string;
  city: string;
  country: string;
}
function createUser(info: UserInfo) {
  // ...
}
```

### 피처 탐욕 (Feature Envy)

> 메서드가 자신이 속하지 않은 다른 객체의 데이터를 지나치게 탐색할 때 나타난다. ([thisprogrammingthing.com][2])

```ts
// 리팩토링 전
class Customer {
  constructor(public orders: Order[]) {}
  totalOrderValue(): number {
    let total = 0;
    for (const o of this.orders) {
      for (const i of o.items) {
        total += i.price * i.quantity;
      }
    }
    return total;
  }
}

// 리팩토링 후
class Order {
  constructor(public items: Item[]) {}
  value(): number {
    return this.items.reduce((sum, i) => sum + i.price * i.quantity, 0);
  }
}
class Customer {
  constructor(public orders: Order[]) {}
  totalOrderValue(): number {
    return this.orders.reduce((sum, o) => sum + o.value(), 0);
  }
}
```

※ 이외에도 위에서 나열한 스멜들이 많으며, 각 스멜은 해당 장(chapter)에서 “이런 형태→이럴 때 리팩토링을 고려하라”는 형태로 설명된다. ([GitHub][1])

---

## 3. 어떻게 이 스멜을 인식하고 대응할 것인가

* 먼저 **자동화된 테스트가 있는 상태**에서 코드를 읽고 스멜이 있는지 탐색한다. 테스트가 없으면 리팩토링은 위험하다. ([ajahne.github.io][3])
* 코드 리딩 시 다음 질문을 던져보자:

  > “이 함수가 한 가지 책임만 갖고 있는가?”, “이 데이터는 한 곳에서만 관리되는가?”, “이 매개변수 목록이 길어서 호출 쪽이 복잡하지 않은가?”
* 스멜이 발견된다면 바로 리팩토링할 필요는 없고, 변화가 필요할 때 (기능 추가, 버그 수정 등) 리팩토링 기회가 생겼을 때 실행하는 것이 좋다. ([ajahne.github.io][3])
* 리팩토링은 **작고 자주** 해야 한다. 너무 많은 것을 한꺼번에 바꾸면 오히려 위험하다. ([GitHub][4])

---

## ✅ 요약

* ‘스멜’을 알면 코드가 나빠지기 전에 경고 울림벨을 인식할 수 있다.
* 스멜은 자동으로 고쳐지지 않는다 — 인식 → 리팩토링 과정이 필요하다.
* 책 속 예시를 실제 코드에 대입해보고, 팀 코드베이스에서 동일한 스멜이 있는지 찾아보는 것이 학습에 큰 도움이 된다.
* **팁**: 위에서 제시한 예시 코드 중 하나를 본인의 프로젝트 또는 연습 코드에 적용해 보고, 리팩토링 전후를 비교해 README나 코드 주석으로 설명해보면 좋다.
