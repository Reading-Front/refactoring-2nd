# API 리팩터링

모듈과 함수는 소프트웨어를 구성하는 빌딩 블록이며, API는 이 블록들을 끼워 맞추는 연결부다. 

좋은 API는 데이터를 갱신하는 함수와 그저 조회만 하는 함수를 명확히 구분한다. 두 기능이 섞여 있다면 **질의 함수와 변경 함수 분리하기**를 적용해 갈라놔야 한다.
값 하나 때문에 여러 개로 나뉜 함수들은 **함수 매개변수화하기**를 적용해 하나로 합칠 수 있다. 

함수의 동작 모드를 전환하는 용도로만 쓰이는 매개변수는 **플래그 인수 제거하기**를 적용하면 좋다.

데이터 구조가 함수 사이를 건너다니면서 필요 이상으로 분해될 때는 **객체 통째로 넘기기**를 적용해 하나로 유지하면 깔끔해진다.
무언가를 매개변수로 건네 피호출 함수가 판단할지 아니면 호출함수가 직접 정할지에 관해서는 상황에 따라 **매개변수를 질의 함수로 바꾸기** 또는 **질의 함수를 매개변수로 바꾸기**로 균형점을 옮길 수 있다.

객체가 불편이길 원하면 **세터 제거하기**를 적용한다. 

호출자에게새로운 객체를 만들어 반환하려 할 때 일반적인 생성자의 능력만으로는 부족할 때는 **생성자를 팩터리 함수로 바꾸기**가 좋은 해법이 될 수 있다.

수많은 데이터를 받는 복잡한 함수를 잘게 쪼개는 문제를 다룰 때는 **함수를 명령으로 바꾸기**를 적용하여 함수를 객체로 변환하면 함수를 추출하기 수월해진다. 
함수를 단순화하여 명령 객체가 더는 필요 없어진다면 **명령을 함수로 바꾸기**를 적용해 함수로 되돌릴 수 있다.

함수 안에서 데이터가 수정됐음을 알리려면 **수정된 값 반환하기**를 적용한다. 
오류 코드에 의존하는 과거 방식 코드는 **오류 코드를 예외로 바꾸기**로 정리한다. 예외는 올바른 상황에서 정확하게 적용해야 한다.
특히, 문제가 되는 조건을 함수 호출 전에 검사할 수 있다면 **예외를 사전 확인으로 바꾸기**로 예외 남용을 줄일 수 있다.


## 1) 질의 함수와 변경 함수 분리하기

외부에서 관찰할 수 있는 겉보기 부수효과가 전혀 없이 값을 반환해주는 함수를 추구해야 한다. 
겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 이를 위한 한 가지 방법은 '질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다'는 규칙을 따르는 것이다. 이를 **명령-질의 분리**라 한다. 

값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하려 시도한다.

### 예제 - 악당 찾기 + 알림 울리기가 섞여 있음

```typescript
function alertForMiscreant(people: Person[]): string {
  for (const p of people) {
    if (p.name === 'Don') {
      setOffAlarms() // 명령     // 부수효과!
      return 'Don';  // 질의 
    }
    if (p.name === 'John') {
      setOffAlarms() // 명령     // 부수효과!
      return 'John'; // 질의
    }
  }
  return '';
}

// 호출부
const found = alertForMiscreant(people)
```

함수를 복제하고 질의 목적에 맞는 이름(findMiscreant)을 짓는다. 

```typescript
function findMiscreant(people: Person[]): string {
  for (const p of people) {
    if (p.name === 'Don') {
      return 'Don';
    }
    if (p.name === 'John') {
      return 'John';
    }
  }
  return ''
}

function alertForMiscreant(people: Person[]): string {
  const name = findMiscreant(people)
  if (name) {
    setOffAlarms()
  }
  return name
}
```

기존 함수를 호출하는 곳을 모두 찾아서 새로운 질의 함수를 호출하도록 바꾸고, 이어서 원래의 변경 함수를 호출하는 코드를 바로 아래에 삽입한다.

```typescript
// Before: 반환값도 쓰고 알람도 필요
const found = alertForMiscreant(people)

// After: 의도에 따라 분리
const found = findMiscreant(people)   // 질의만
alertForMiscreant(people)              // 알람도 필요할 때
```

## 2) 함수 매개변수화하기

값 하나 때문에 여러 개로 나뉜 함수들은 매개변수를 추가하여 하나로 합침으로써 코드 중복을 줄일 수 있다.

두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다. 
이렇게 하면 매개변수 값만 바꿔서 여러 곳에서 쓸 수 있으니 함수의 유용성이 커진다.

### 예제 - 구간별 사용 요금 계산

```typescript
// ❌ Before: 범위 조건만 다른 세 함수
function baseCharge(usage: number): number {
  if (usage < 0) return 0
  
  const amount = 
    bottomBand(usage) * 0.03 +
    middleBand(usage) * 0.05 +
    topBand(usage) * 0.07
    
  return amount
}

// 각 구간별 사용량 계산 함수들
function bottomBand(usage: number): number {
  return Math.min(usage, 100)
}

function middleBand(usage: number): number {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0
}

function topBand(usage: number): number {
  return usage > 200 ? usage - 200 : 0
}

// bottomBand: 0 ~ 100 구간
// middleBand: 100 ~ 200 구간  
// topBand: 200 ~ ∞ 구간

// ✅ After: 통합된 범위 계산 함수
function withinBand(usage: number, bottom: number, top: number): number {
  return usage > bottom ? Math.min(usage, top) - bottom : 0
}

function baseCharge(usage: number): number {
  if (usage < 0) return 0
  
  const amount = 
    withinBand(usage, 0, 100) * 0.03 +      // bottomBand
    withinBand(usage, 100, 200) * 0.05 +    // middleBand
    withinBand(usage, 200, Infinity) * 0.07 // topBand
    
  return amount
}

```

## 3) 플래그 인수 제거하기

함수의 동작 모드를 전환하는 용도로만 쓰이는 매개변수(플래그 인수)가 있다면, 이를 제거하고 명시적인 개별 함수들로 분리하는 것이 좋다.

플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다. 
플래그 인수는 호출하는 쪽에서 불리언 값으로 리터럴 값을 건네고, 호출되는 함수는 그 인수를 제어 흐름을 결정하는 데 사용한다.

플래그 인수를 사용하는 방식은 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이래하기 어려워진다. 플래그 인수가 있으면 함수들의 기능 차이가 잘 드러나지 않으며, 사용할 함수를 선택한 후에도 플래그 인수로 어떤 값을 넘겨야 하는지를 또 알아내야 한다. 불리언 플래그는 코드를 읽는 이에게 뜻을 올전히 전달하지 못하기 때문에 더욱 좋지 못하다. 이보다는 특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다.

플래그 인수를 제거하면 코드가 깔끔해지며, 분리된 함수로 호출 로직을 더 쉽게 파악할 수 있게 되어 코드 분석 도구에도 도움을 준다.

함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수르 ㄹ써야 하는 합당한 근거가 될 수 있다. 
플래그 인수 없이 구현하면 플래그 인수들의 가능한 조합 수만큼의 함수를 만들어야 하기 때문이다. 
그런데 다른 관점에서 보자면, 플래그 인수가 둘 이상이면 함수 하나가 너무 많은 일을 처리하고 있다는 신호이기도 하다.
그러니 같은 로직을 조합해내는 더 간단한 함수를 만들 방법을 고민해봐야 한다.

[절차]
1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다.
2. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다.

### 예제 - 배송비 계산

```typescript
// ❌ Before: 플래그 인수 사용
// 호출부를 보면 true/false가 무슨 의미인지 알 수 없음

function deliveryDate(order: Order, isRush: boolean): Date {
  if (isRush) {
    let deliveryTime: number
    if (['MA', 'CT'].includes(order.deliveryState)) {
      deliveryTime = 1
    } else if (['NY', 'NH'].includes(order.deliveryState)) {
      deliveryTime = 2
    } else {
      deliveryTime = 3
    }
    return addDays(order.placedOn, 1 + deliveryTime)
  } else {
    let deliveryTime: number
    if (['MA', 'CT', 'NY'].includes(order.deliveryState)) {
      deliveryTime = 2
    } else if (['ME', 'NH'].includes(order.deliveryState)) {
      deliveryTime = 3
    } else {
      deliveryTime = 4
    }
    return addDays(order.placedOn, 2 + deliveryTime)
  }
}

// 호출부 - true가 뭘 의미하는지 알 수 없음 💥
const arrival1 = deliveryDate(order, true)
const arrival2 = deliveryDate(order, false)


// ✅ After: 최종 결과 - 명시적인 두 함수만 남음

function rushDeliveryDate(order: Order): Date {
  let deliveryTime: number
  if (['MA', 'CT'].includes(order.deliveryState)) {
    deliveryTime = 1
  } else if (['NY', 'NH'].includes(order.deliveryState)) {
    deliveryTime = 2
  } else {
    deliveryTime = 3
  }
  return addDays(order.placedOn, 1 + deliveryTime)
}

function regularDeliveryDate(order: Order): Date {
  let deliveryTime: number
  if (['MA', 'CT', 'NY'].includes(order.deliveryState)) {
    deliveryTime = 2
  } else if (['ME', 'NH'].includes(order.deliveryState)) {
    deliveryTime = 3
  } else {
    deliveryTime = 4
  }
  return addDays(order.placedOn, 2 + deliveryTime)
}

// 호출부 - 함수 이름만 봐도 의도 파악 가능
const rushArrival = rushDeliveryDate(order)
const normalArrival = regularDeliveryDate(order)
```

## 4) 객체 통째로 넘기기

데이터 구조가 함수 사이를 건너다니며 필요 이상으로 분해될 때, 객체 전체를 인수로 넘기면 매개변수 목록이 깔끔해지고 변화에 유연하게 대응할 수 있다.

하나의 레코드에서 값 두어 개를 가져와 인수로 넘기는 코드를 보면, 그 값들 대신 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다.
레코드를 통째로 넘기면 변화에 대응하기 쉽다. 또한 매개변수 목록도 짧아진다.

하지만 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는다. 레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다. 

한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출하라는 신호일 수 있다. 

다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우, 이런 상황이면 데이터 여러 개 대신 객체 자신의 참조만 건네도록 수정할 수 있다.


```typescript
// ❌ Before: 값을 꺼내서 개별 인수로 전달
// ------------------------------------------------------------

class HeatingPlan {
  constructor(min, max) {
    this._temperatureRange = { low: min, high: max }
  }
  
  withinRange(bottom, top) {
    return bottom >= this._temperatureRange.low 
        && top <= this._temperatureRange.high
  }
}

// 호출부
const low = aRoom.daysTempRange.low
const high = aRoom.daysTempRange.high

if (!aPlan.withinRange(low, high)) {
  alerts.push(`${aRoom.name} 방 온도가 범위를 벗어났습니다.`)
}

// 문제점:
// - 값을 일일이 꺼내야 함
// - daysTempRange에 필드 추가 시 호출부도 수정 필요
// - 매개변수 순서 실수 가능



// ✅ After: 범위 객체를 통째로 전달
// ------------------------------------------------------------

class HeatingPlan {
  constructor(min, max) {
    this._temperatureRange = { low: min, high: max }
  }
  
  withinRange(aNumberRange) {
    return aNumberRange.low >= this._temperatureRange.low 
        && aNumberRange.high <= this._temperatureRange.high
  }
}

// 호출부 - 깔끔해짐
if (!aPlan.withinRange(aRoom.daysTempRange)) {
  alerts.push(`${aRoom.name} 방 온도가 범위를 벗어났습니다.`)
}

// 장점:
// - 호출부가 간결함
// - daysTempRange 구조 변경에 유연함
// - 매개변수 순서 실수 없음
```

## 5) 매개변수를 질의 함수로 바꾸기 

피호출 함수가 스스로 판단하게 할지, 호출 함수가 직접 결정해서 넘길지에 따라 매개변수와 질의 함수 사이의 균형점을 옮겨 의존성을 관리한다.

매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다. 
이 목록도 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽다.

피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다.

매개변수를 제거하면 값을 결정하는 책임 주체가 달라진다. 피호출 함수가 역할을 하기에 적합할 경우 책임 소재를 피호출 함수로 옮겨 호출하는 쪽을 간소하게 만든다. 

매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다. 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때다. 즉, 해당 함수가 알지 못했으면 하는 프로그램 요소에 접근해야 하는 상황을 만들 때다. 이런 상황은 주로 함수 본문에서 문제의 외부 함수를 호출해야 하거나 나중에 함수 밖으로 빼내길 원하는 수용 객체(receiver object)에 담긴 데이터를 사용해야 할 때 일어난다.

제거하려는 매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있다면 안심하고 질의 함수로 바꿀 수 있다. 다른 매개변수에서 얻을 수 있는 값을 별도 매개변수로 전달하는 것은 아무 의미가 없다.

주의사항은 대상 함수가 참조 투명해야 한다는 것이다. 
**참조 투명**이란 '함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다'는 뜻이다.
따라서 매개변수를 없애는 대신 가변 전역 변수를 이용하는 일은 하면 안 된다.

```javascript
// ❌ Before: 다른 매개변수에서 얻을 수 있는 값을 별도로 전달
// ------------------------------------------------------------

class Order {
  constructor(quantity, itemPrice) {
    this.quantity = quantity
    this.itemPrice = itemPrice
  }
  
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice
    let discountLevel
    
    if (this.quantity > 100) discountLevel = 2
    else discountLevel = 1
    
    return this.discountedPrice(basePrice, discountLevel)
  }
  
  // discountLevel은 basePrice나 quantity에서 얻을 수 있는 값
  // 굳이 매개변수로 받을 필요 없음 💥
  discountedPrice(basePrice, discountLevel) {
    switch (discountLevel) {
      case 1: return basePrice * 0.95
      case 2: return basePrice * 0.90
    }
  }
}

// ✅ After: 피호출 함수가 스스로 질의해서 결정
// ------------------------------------------------------------

class Order {
  constructor(quantity, itemPrice) {
    this.quantity = quantity
    this.itemPrice = itemPrice
  }
  
  get finalPrice() {
    const basePrice = this.quantity * this.itemPrice
    return this.discountedPrice(basePrice)
  }
  
  // 할인 등급은 스스로 질의해서 결정
  discountedPrice(basePrice) {
    switch (this.discountLevel) {
      case 1: return basePrice * 0.95
      case 2: return basePrice * 0.90
    }
  }
  
  // 질의 함수로 추출
  get discountLevel() {
    return this.quantity > 100 ? 2 : 1
  }
}
```

## 6) 질의 함수를 매개변수로 바꾸기

코드를 읽다 보면 함수 안에서 전역 변수를 참조한다거나 제거하길 원하는 원소를 참조하는 경우가 있다. 
이 문제는 해당 참조를 매개벼수로 바꿔 해결할 수 있다. 참조를 풀어내는 책임을 호출자로 옮기는 것이다.

이런 상황 대부분은 코드의 의존 관계를 바꾸려 할 때 벌어진다.
대상 함수가 더 이상 특정 원소에 의존하길 원치 않을 때다. 이때 두 극단 사이에서 적절한 균형을 찾아야 한다.
한쪽 끝은 모든 것을 매개변수로 바꿔 아주 길고 반복적인 매개변수 목록을 만드는 것이고, 다른 쪽 끝은 함수들끼리 만은 것을 공유하여 수많은 결합을 만들어내는 것이다. 대다수 까다로운 결정이 그렇듯, 이 역시 한 시점에 내린 결정이 영원히 옳다고 할 수는 없다. 

똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다. 이런 성질을 '참조 투명성'이라 한다. 
참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다.
책임이 호출자로 옮겨진다는 점을 고려해야 하지만, 모듈을 참조 투명하게 만들어 얻는 장점은 대체로 아주 크다. 
그래서 모듈을 개발할 때 순수 함수들을 따로 구분하고, 프로그램의 입출력과 기타 가변 원소들을 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이 활용한다. 
그리고 이번 리팩터링을 활용하면 프로그램의 일부를 순수 함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트하거나 다루기가 쉬워진다.

질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 한다. 결국 호출자가 복잡해진다. 
따라서 이 문제는 결국 책임 소재를 프로그램의 어디에 배정하느냐의 문제로 귀결된다. 

```javascript
/ ❌ Before: 함수 내부에서 전역 변수 참조
// ------------------------------------------------------------

// 전역 객체 - 현재 온도를 가진 온도조절기
const thermostat = {
  currentTemperature: 22,
  // ... 기타 상태
}

class HeatingPlan {
  constructor(max, min) {
    this._max = max
    this._min = min
  }
  
  get targetTemperature() {
    // 전역 변수 직접 참조 💥
    // - 테스트하기 어려움
    // - 참조 투명성 없음 (thermostat 상태에 따라 결과 달라짐)
    if (thermostat.currentTemperature > this._max) {
      return this._max
    } else if (thermostat.currentTemperature < this._min) {
      return this._min
    } else {
      return thermostat.currentTemperature
    }
  }
}

// 호출부
const plan = new HeatingPlan(25, 18)
const target = plan.targetTemperature


// ✅ After: 전역 참조를 매개변수로 바꿈
// ------------------------------------------------------------

class HeatingPlan {
  constructor(max, min) {
    this._max = max
    this._min = min
  }
  
  // 현재 온도를 매개변수로 받음
  // - 순수 함수가 됨
  // - 테스트 용이
  // - 참조 투명성 확보
  targetTemperature(currentTemperature) {
    if (currentTemperature > this._max) {
      return this._max
    } else if (currentTemperature < this._min) {
      return this._min
    } else {
      return currentTemperature
    }
  }
}

// 호출부 - 전역 참조 책임이 여기로 이동
const plan = new HeatingPlan(25, 18)
const target = plan.targetTemperature(thermostat.currentTemperature)
```

## 7) 세터 제거하기

객체가 생성된 후 값이 변경되지 않는 '불변' 상태이길 원한다면, 필드를 수정하는 세터(Setter) 메서드를 제거한다.

세터 메서드가 있다는 것은 필드가 수정될 수 있다는 것이다. 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않으며, 해당 필드는 오직 생성자에서만 설정되며, 수정하지 않겠다는 의도가 명명백백해지고, 변경될 가능성이 봉쇄된다. 

세터 제거하기 리팩터링이 필요한 상황은 주로 두 가지다. 
첫째, 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다. 심지어 생성자 안에서도 말이다. 이러면 오직 생성자에서만 호출하는 세터가 생기곤 한다. 
둘째, 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때다. 
생성 스크립트란 생성자를 호출한 후 일련의 세터를 호출하여 객체를 완성하는 형태의 코드를 말한다.
그러면서 설계자는 스크립트가 완료된 뒤로는 그 객체의 필드 일부(혹은 전체)는 변경되지 않으리라 기대한다. 
즉, 해당 세터들은 처음 생성할 때만 호출되리라 가정한다. 이런 경우에도 세터들을 제거하여 의도를 더 정확하게 전달하는 게 좋다.

```javascript
// ❌ Before: 세터가 있어 변경 가능해 보임
// ------------------------------------------------------------

class Person {
  constructor() {
    // 생성자에서 세터를 통해 설정
  }
  
  get name() { return this._name }
  set name(arg) { this._name = arg }
  
  get id() { return this._id }
  set id(arg) { this._id = arg }  // id는 변경되면 안 되는데... 💥
}

// 생성 스크립트 - 세터로 객체 완성
const martin = new Person()
martin.name = 'martin'
martin.id = '1234'

// 문제: id 세터가 있어서 나중에 변경 가능해 보임
martin.id = '5678'  // 이런 실수가 가능함!



// ✅ After: 불변 필드는 생성자에서만 설정
// ------------------------------------------------------------

class Person {
  constructor(id) {
    this._id = id  // 생성자에서만 설정
  }
  
  get name() { return this._name }
  set name(arg) { this._name = arg }  // name은 변경 가능
  
  get id() { return this._id }
  // id 세터 제거 - 변경 불가 의도 명확
}

// 호출부
const martin = new Person('1234')
martin.name = 'martin'

// martin.id = '5678'  // 컴파일 에러 또는 무시됨 ✅
```

## 8) 생성자를 팩터리 함수로 바꾸기

객체를 생성할 때 일반적인 생성자의 기능만으로는 부족하거나, 서브클래스 반환 등 유연한 생성이 필요할 때 팩터리 함수를 도입한다.

많은 객체 지향 언어에서 제공하는 생성자는 객체를 초기화하는 특별한 용도의 함수다. 실제로 새로운 객체를 생성할 대면 주로 생성자를 호출한다. 
하지만 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙기도 한다. 서브클래스의 인스턴스나 프락시를 반환할 수는 없다. 생성자의 이름도 고정되어, 기본 이름보다 더 적절한 이름이 있어도 사용할 수 없다. 생성자를 호출하려면 new를 사요앻야 해서 일반 함수가 기대하는 자리에는 쓰기 어렵다.

팩터리 함수에는 이런 제약이 없다. 팩털이 함수를 구현하는 과정에서 생성자를 호출할 수는 있지만, 원한다면 다른 무언가로 대체할 수 있다.

```javascript
// Before
leadEngineer = new Employee(document.leadEngineer, 'E');

// After
leadEngineer = createEngineer(document.leadEngineer);
```

## 9) 함수를 명령으로 바꾸기

수많은 데이터를 받는 복잡한 함수를 쪼개기 어려울 때, 함수를 '명령(Command) 객체'로 변환하면 멤버 변수를 활용해 함수 추출을 더 수월하게 할 수 있다.

함수(독립된 함수든 객체에 소속된 메서드든)는 프로그래밍의 기본적인 빌딩 블록 중 하나다.
그런데 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 '명령 객체' 혹은 단순히 '명령'이라 한다.
명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.

명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다. 명령은 되돌리기 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다. 

상속과 훅을 이용해 사용자 맞춤형을 만들 수도 있다. 객체는 지원하지만 일급 함수를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내 낼 수 있다. 비슷하게, 중첩 함수를 지원하지 않는 언어에서도 메서드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메서드들을 테스트와 디버깅에 직접 이용할 수 있다.

명령을 사용해 얻는 이점이 많으므로 함수를 명령으로 리팩터링할 수 있다. 하지만 유연성은 복잡성을 키우고 얻는 대가임을 잊지 말아야 한다.
그래서 일급 함수와 명령 중 대부분은 일급 함수를 선택한다. 명령을 선택할 때는 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때 명령을 사용한다.
예를 들어, 복잡한 함수를 잘게 조개서 이해하거나 수정하기 쉽게 만들고자 할 때가 있다. 명령의 수명주기나 사용자 정의 기능 등을 지원해야 해서 매개변수가 복잡할 때는 아주 편리하다. 매개변수 목록이 서로 다른 여러 형태의 명령들을 하나의 실행 대기열을 통해 전달할 수도 있다.

[절차]

1. 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다.
2. 방금 생성한 빈 클래스로 함수를 옮긴다.
3. 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다.


```javascript
// ============================================================
// 함수를 명령으로 바꾸기 (Replace Function with Command)
// 보험료 계산 예제
// ============================================================

// ❌ Before: 복잡한 함수 - 쪼개기 어려움
// ------------------------------------------------------------

function score(candidate, medicalExam, scoringGuide) {
  let result = 0
  let healthLevel = 0
  let highMedicalRiskFlag = false
  
  if (medicalExam.isSmoker) {
    healthLevel += 10
    highMedicalRiskFlag = true
  }
  
  let certificationGrade = 'regular'
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = 'low'
    result -= 5
  }
  
  // ... 수많은 계산 로직
  result -= Math.max(healthLevel - 5, 0)
  
  return result
}

// 문제:
// - 지역 변수가 많아 함수 추출이 어려움
// - 테스트하기 어려움
// - 중간 계산 과정을 확인하기 어려움



// ✅ After: 명령 객체로 변환
// ------------------------------------------------------------

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate
    this._medicalExam = medicalExam
    this._scoringGuide = scoringGuide
  }
  
  execute() {
    this._result = 0
    this._healthLevel = 0
    this._highMedicalRiskFlag = false
    
    this._scoreSmoking()
    this._scoreCertification()
    this._applyHealthPenalty()
    
    return this._result
  }
  
  // 복잡한 로직을 메서드로 쉽게 추출
  _scoreSmoking() {
    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10
      this._highMedicalRiskFlag = true
    }
  }
  
  _scoreCertification() {
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
      this._certificationGrade = 'low'
      this._result -= 5
    } else {
      this._certificationGrade = 'regular'
    }
  }
  
  _applyHealthPenalty() {
    this._result -= Math.max(this._healthLevel - 5, 0)
  }
}

// 호출부
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute()
}

// 장점:
// - 지역 변수 → 멤버 변수로 변환하여 메서드 추출 용이
// - 각 계산 단계를 개별 메서드로 분리
// - 중간 상태 테스트/디버깅 가능
// - 상속으로 확장 가능



// ============================================================
// 명령 객체의 추가 기능 활용
// ============================================================

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate
    this._medicalExam = medicalExam
    this._scoringGuide = scoringGuide
  }
  
  execute() {
    this._result = 0
    this._healthLevel = 0
    this._scoreSmoking()
    this._scoreCertification()
    return this._result
  }
  
  // 중간 상태 확인 가능 (디버깅용)
  get healthLevel() { return this._healthLevel }
  get certificationGrade() { return this._certificationGrade }
  
  // 되돌리기 연산 제공 가능
  undo() {
    // 이전 상태로 복원하는 로직
  }
  
  // ... 메서드들
}

// 테스트에서 중간 상태 검증 가능
test('흡연자는 healthLevel이 10 증가', () => {
  const scorer = new Scorer(candidate, { isSmoker: true }, guide)
  scorer.execute()
  expect(scorer.healthLevel).toBe(10)  // 중간 상태 확인 ✅
})
``` 

명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다. 큰 연산 하나를 여러 개의 작은 메서드로 쪼개고 필드를 이용해 쪼개진 메서들끼리 정보를 공유할 수 있다. 또한 어떤 메서드를 호출하냐에 따라 다른 효과를 줄 수 있고 각 단계를 거치며 데이터를 조금씩 완성해갈 수도 있다. 

## 10) 명령을 함수로 바꾸기

로직이 단순해져서 더 이상 복잡한 명령 객체가 필요하지 않게 된다면, 다시 단순한 함수 형태로 되돌린다.

명령의 능력은 공짜가 아니다. 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.

```javascript
// ❌ Before: 단순한 로직인데 명령 객체로 과하게 구현
// ------------------------------------------------------------

class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer
    this._usage = usage
    this._provider = provider
  }
  
  get baseCharge() {
    return this._customer.baseRate * this._usage
  }
  
  get charge() {
    return this.baseCharge + this._provider.connectionCharge
  }
}

// 호출부
const monthCharge = new ChargeCalculator(customer, usage, provider).charge

// 문제:
// - 로직이 단순한데 클래스로 감쌈
// - 불필요한 복잡성
// - 호출부도 장황함



// ✅ After: 단순한 함수로 변환
// ------------------------------------------------------------

function charge(customer, usage, provider) {
  const baseCharge = customer.baseRate * usage
  return baseCharge + provider.connectionCharge
}

// 호출부 - 간결해짐
const monthCharge = charge(customer, usage, provider)

// 장점:
// - 단순한 로직에 맞는 단순한 구조
// - 호출부가 명확
// - 불필요한 클래스 제거
```

## 11) 수정된 값 반환하기

데이터가 어떻게 수정되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나이다.
특히 같은 데이터 블록을 읽고 수정하는 코드가 여러 곳이라면 데이터가 수정되는 흐름과 코드의 흐름을 일치시키기가 상당히 어렵다. 
그래서 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.

데이터가 수정됨을 알려주는 좋은 방법이 있다. 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다.
이 방식으로 코딩하면 호출자 코드를 읽을 때 변수가 갱신될 것임을 분명히 인지하게 된다. 해당 변수의 값을 단 한 번만 정하면 될 때 특히 유용하다.

이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다. 

### GPS 거리 계산 예제

```javascript
// ❌ Before: 함수가 외부 변수를 직접 수정
// ------------------------------------------------------------

let totalAscent = 0
let totalTime = 0
let totalDistance = 0

function calculateAscent() {
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation
    if (verticalChange > 0) {
      totalAscent += verticalChange  // 외부 변수 직접 수정 💥
    }
  }
}

function calculateTime() {
  // totalTime 수정...
}

function calculateDistance() {
  // totalDistance 수정...
}

// 호출부 - 변수가 언제 수정되는지 알기 어려움
calculateAscent()
calculateTime()
calculateDistance()

console.log(`총 상승: ${totalAscent}`)

// 문제:
// - 함수 호출만 보면 totalAscent가 바뀌는지 모름
// - 데이터 흐름 추적 어려움
// - 함수 실행 순서에 의존

// ✅ After: 수정된 값을 반환
// ------------------------------------------------------------

function calculateAscent(points) {
  let result = 0
  for (let i = 1; i < points.length; i++) {
    const verticalChange = points[i].elevation - points[i - 1].elevation
    if (verticalChange > 0) {
      result += verticalChange
    }
  }
  return result  // 계산된 값 반환
}

function calculateTime(points) {
  // ... 계산 후 반환
  return result
}

function calculateDistance(points) {
  // ... 계산 후 반환
  return result
}

// 호출부 - 변수 갱신이 명확히 보임
const totalAscent = calculateAscent(points)
const totalTime = calculateTime(points)
const totalDistance = calculateDistance(points)

console.log(`총 상승: ${totalAscent}`)
```

## 12) 오류 코드를 예외로 바꾸기

예전에는 오류 코드를 사용하는 게 보편적이었다. 함수를 호출하면 언제든 오류가 반환될 수 있었고, 그래서 오류 코드 검사를 빼먹으면 안 됐다. 
오류 코드를 검사해서 발생한 오류를 직접 처리하거나 다른 누군가가 처리해주길 기대하며 콜수택 위로 던져보냈다.

**예외**는 프로그래밍 언어에서 제공하는 독립적인 오류 메커니즘이다. 
오류가 발견되면 예외를 던진다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다. 
예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경쓰지 않아도 된다. 
예외에는 독자적인 흐름이 있어서 프로그램의 나머지에서는 오류 발생에 따른 복잡한 상황에 대처하는 코드를 작성하거나 읽을 일이 없게 해준다.

예외는 정교한 메커니즘이지만 대다수의 다른 정교한 메커니즘과 같이 정확하게 사용할 때만 최고의 효과를 낸다. 
예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다. 달리 말하면 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.

괜찮은 방법이 있다. 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할지를 따져보는 것이다. 
정상 동작하지 않을 것 같다면 예외를 사용하지 말라는 신호다. 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다.

어떤 함수에서 오류가 난다면 무엇가 잘못됐음을 뜻하는 경우, 호출한 곳에서는 반환된 오류 코드를 검사하여 오류가 발견되면 위로 전파한다.
여기서 가장 먼저 고려할 것은 오류가 '예상된 것이냐'다. 예상할 수 있는 정상 동작 범주에 든다면 오류 코드를 예외로 바꾸는 리팩터링을 적용할 준비가 된 것이다.

```javascript
// ❌ Before: 오류 코드 반환 방식
// ------------------------------------------------------------

function localShippingRules(country) {
  const data = countryData.shippingRules[country]
  if (data) return new ShippingRules(data)
  return -23  // 오류 코드 반환 💥
}

function calculateShippingCosts(order) {
  // ...
  const shippingRules = localShippingRules(order.country)
  
  if (shippingRules < 0) {
    return shippingRules  // 오류 코드를 위로 전파 💥
  }
  
  // ... 정상 로직
}

// 호출부 - 오류 코드 검사 필수
const cost = calculateShippingCosts(order)
if (cost < 0) {
  handleError(cost)  // 매번 검사해야 함
} else {
  displayCost(cost)
}

// 문제:
// - 오류 코드(-23)의 의미가 불분명
// - 모든 호출부에서 오류 검사 필요
// - 오류 검사 누락 시 버그 발생
// - 정상 흐름과 오류 흐름이 섞임


// ✅ After: 예외 사용
// ------------------------------------------------------------

class OrderProcessingError extends Error {
  constructor(errorCode) {
    super(`주문 처리 오류: ${errorCode}`)
    this.code = errorCode
  }
}

function localShippingRules(country) {
  const data = countryData.shippingRules[country]
  if (data) return new ShippingRules(data)
  throw new OrderProcessingError(-23)  // 예외 던지기
}

function calculateShippingCosts(order) {
  // ...
  const shippingRules = localShippingRules(order.country)
  // 오류 전파 코드 불필요 - 예외가 알아서 전파됨
  // ... 정상 로직만 작성
}

// 호출부 - 예외 핸들러에서 한 번에 처리
try {
  const cost = calculateShippingCosts(order)
  displayCost(cost)
} catch (e) {
  if (e instanceof OrderProcessingError) {
    handleError(e)
  } else {
    throw e  // 예상 못한 예외는 다시 던짐
  }
}

```

## 13) 예외를 사전 확인으로 바꾸기

예외라는 개념은 프로그래밍 언어의 발전에 의미 있는 한걸음이었다. 오류 코드를 연쇄적으로 전파하던 긴 코드를 예외로 바꿔 깔끔히 제거할 수 있게 되었으니 말이다.
하지만 예외도 과용되곤 한다. 예외는 '뜻밖의 오류'라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.

```javascript
// ❌ Before: 예상 가능한 상황에 예외 사용
// ------------------------------------------------------------

class ResourcePool {
  constructor() {
    this._available = []
    this._allocated = []
  }
  
  get() {
    const result = this._available.pop()
    if (result === undefined) {
      throw new Error('자원이 없습니다')  // 예외 과용 💥
    }
    this._allocated.push(result)
    return result
  }
}

// 호출부 - 예상 가능한 상황을 예외로 처리
try {
  const resource = pool.get()
  useResource(resource)
} catch (e) {
  createNewResource()  // 자원 없으면 새로 생성
}

// 문제:
// - 자원이 없는 건 "예외"가 아니라 "예상 가능한 상황"
// - 정상 흐름을 예외로 제어함
// - 예외의 의미가 희석됨


// ✅ After: 사전 확인으로 변경
// ------------------------------------------------------------

class ResourcePool {
  constructor() {
    this._available = []
    this._allocated = []
  }
  
  // 사전 확인용 메서드 추가
  get isEmpty() {
    return this._available.length === 0
  }
  
  get() {
    if (this.isEmpty) {
      throw new Error('자원이 없습니다')  // 진짜 예외 상황용
    }
    const result = this._available.pop()
    this._allocated.push(result)
    return result
  }
}

// 호출부 - 사전 확인 후 처리
if (pool.isEmpty) {
  createNewResource()
} else {
  const resource = pool.get()
  useResource(resource)
}
```

## (+) 
