# 9장 데이터 조직화

## 9.1 변수 쪼개기 (Split Variable)

여러 역할을 한 변수에 몰아 쓰면, 어느 시점에 어떤 의미인지 추적하기 어려워지고 버그가 잘 생긴다. 
수집 변수(합계, 결과 누적 등)가 아닌데 여러 책임을 가진다면, 역할별로 변수를 나누어 각각 한 가지 의미만 갖게 해야 한다.

```ts
// Before: temp가 '둘레'와 '넓이' 두 역할을 모두 담당
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);

// After: 의미별로 쪼갬
const perimeter = 2 * (height + width);
console.log(perimeter);

const area = height * width;
console.log(area);
```

***

## 9.2 필드 이름 바꾸기 (Rename Field)

데이터 구조는 프로그램을 이해하는 데 큰 역할을 하므로, 필드 이름이 의미를 잘 드러나야 한다. 
도메인에 대한 이해가 깊어져서 더 적절한 이름을 떠올렸다면, 점진적으로 필드 이름을 바꾸어 코드 전체에서 의도가 일관되게 보이도록 한다.

```ts
// Before: name이 의미가 모호하거나 도메인 용어와 다를 수 있음
class Organization {
  private _name: string;

  constructor(data: { name: string }) {
    this._name = data.name;
  }

  get name(): string {
    return this._name;
  }
}

// After: 도메인에 맞는 이름으로 변경 (예: title)
class Organization {
  private _title: string;

  constructor(data: { title: string }) {
    this._title = data.title;
  }

  get title(): string {
    return this._title;
  }
}
```


## 9.3 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)

다른 값들로부터 쉽게 계산할 수 있는 “파생 값”을 별도 필드로 저장하면, 
값이 서로 어긋나 일관성이 깨지기 쉽다. 이런 값은 필드로 유지하지 말고, 필요할 때마다 계산하는 게터(질의 함수)로 바꾸어 항상 최신 상태를 보장한다.

```ts
// Before: 할인이 바뀔 때마다 _discountedTotal을 직접 관리해야 함
class Order {
  private _baseTotal: number;
  private _discount: number;
  private _discountedTotal: number;

  constructor(baseTotal: number, discount: number) {
    this._baseTotal = baseTotal;
    this._discount = discount;
    this._discountedTotal = baseTotal - discount;
  }

  set discount(aNumber: number) {
    const old = this._discount;
    this._discount = aNumber;
    this._discountedTotal += old - aNumber; // 상태 관리가 복잡
  }

  get discountedTotal(): number {
    return this._discountedTotal;
  }
}

// After: 항상 계산해서 반환
class OrderRefactored {
  private _baseTotal: number;
  private _discount: number;

  constructor(baseTotal: number, discount: number) {
    this._baseTotal = baseTotal;
    this._discount = discount;
  }

  set discount(aNumber: number) {
    this._discount = aNumber;
  }

  get discountedTotal(): number {
    return this._baseTotal - this._discount;
  }
}
```

## 9.4 참조를 값으로 바꾸기 (Change Reference to Value)

작고 거의 변하지 않고, 객체의 “정체성”보다 “값의 동등성”이 중요한 경우에는 공유 참조로 관리하는 것보다 값 객체로 다루는 편이 단순하다.
값 객체는 복사해도 문제 없고, 동등성 비교도 값 기준으로 하면 되므로 설계가 깔끔해진다.

```ts
// Before: 작은 Currency 객체를 여기저기 참조로 공유
class Currency {
  constructor(private _code: string) {}
  get code(): string {
    return this._code;
  }
}

class MoneyBefore {
  constructor(
    private _amount: number,
    private _currency: Currency, // 참조 공유
  ) {}

  get currency(): Currency {
    return this._currency;
  }
}

// After: 통화 코드를 값으로 보관(또는 불변 값 객체로 설계)
class Money {
  constructor(
    private _amount: number,
    private _currencyCode: string, // 예: "USD", "KRW"
  ) {}

  get currencyCode(): string {
    return this._currencyCode;
  }

  equals(other: Money): boolean {
    return (
      this._amount === other._amount &&
      this._currencyCode === other._currencyCode
    );
  }
}
```

## 9.5 값을 참조로 바꾸기 (Change Value to Reference)

논리적으로 “하나만 존재해야 하는” 데이터(고객, 상품 등)를 값 복사로 여러 개 만들어 사용하면, 
변경이 분산되어 일관성이 깨진다. 이런 경우에는 레포지토리나 팩토리를 통해 단일 인스턴스를 공유해, 시스템 전체가 같은 객체를 바라보도록 바꾸는 것이 좋다.

```ts
// Before: 같은 고객 데이터를 여러 곳에서 복제
type CustomerData = { id: number; name: string };

class Customer {
  constructor(private _id: number, private _name: string) {}

  get id(): number {
    return this._id;
  }
  get name(): string {
    return this._name;
  }
}

// 필요할 때마다 새로 생성
const customerData: CustomerData = { id: 1, name: "Alice" };
const c1 = new Customer(customerData.id, customerData.name);
const c2 = new Customer(customerData.id, customerData.name); // 논리적으로는 같은 고객인데 인스턴스는 두 개

// After: 저장소를 통해 하나의 참조를 공유
class CustomerRepository {
  private _customers = new Map<number, Customer>();

  register(data: CustomerData): void {
    const customer = new Customer(data.id, data.name);
    this._customers.set(customer.id, customer);
  }

  find(id: number): Customer | undefined {
    return this._customers.get(id);
  }
}

const repository = new CustomerRepository();
repository.register(customerData);

const customer1 = repository.find(1);
const customer2 = repository.find(1); // 같은 인스턴스를 공유
```

## 9.6 매직 리터럴 바꾸기 (Replace Magic Literal)

의미를 알 수 없는 숫자·문자 상수(매직 리터럴)는 읽는 사람에게 의도를 숨긴다. 
이름이 붙은 상수나 enum으로 치환해 “왜 이 값인지”가 드러나게 만들면, 코드 이해도와 변경 용이성이 모두 올라간다.

```ts
// Before
function potentialEnergy(mass: number, height: number): number {
  return mass * 9.81 * height; // 9.81이 무엇을 의미하는지 코드만 보고 알기 어려움
}

// After: 의미 있는 상수 도입
const STANDARD_GRAVITY = 9.81; // [m/s^2] 지구 표준 중력 가속도

function potentialEnergyRefactored(
  mass: number,
  height: number,
): number {
  return mass * STANDARD_GRAVITY * height;
}
```
