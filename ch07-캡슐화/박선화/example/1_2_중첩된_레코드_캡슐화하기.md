# 1-2 중첩된 레코드 캡슐화하기

JSON 문서처럼 여러 겹 중첩된 레코드의 경우에도 리팩터링 기본 절차는 똑같다.

<details>
<summary>중첩된 레코드 예시</summary>

```JSON
{
  1920: {
    name: 'Martin Fowler',
    id: '1920',
    usages: {
      2016: {
        1: 50,
        2: 55,
        // 나머지 달 생략
      },
      2015: {
        1: 70,
        2: 63,
        // 나머지 달 생략
      },
    },
  },
  38673: {
    name: 'Kent Beck',
    id: '38673',
    usages: {
      2016: {
        1: 40,
        2: 42,
        // 나머지 달 생략
      },
      2015: {
        1: 60,
        2: 59,
        // 나머지 달 생략
      },
    },
  },
}
```

</details>

```javascript
let customerId = 1920

// 쓰기
// customerData[customerId].usages[year][month] = amount;
customerData[customerId].usages[2016][1] = 100

// 읽기
function compareUsage(customerId, laterYear, month) {
  const later = customerData[customerId].usages[laterYear][month]
  const earlier = customerData[customerId].usages[laterYear - 1][month]
  return { laterAmount: later, change: later - earlier }
}
```

## 캡슐화하기

```javascript
const data = {...}

class CustomerData {
  constructor(data) {
    this._data = data
  }
  get usages() {
    return this._data.usages
  }

  get rawData() {
    // lodash 라이브러리의 cloneDeep 메서드 사용
    return _.cloneDeep(this._data)
  }

  setUsage(customerID, year, month, amount) {
    this._data[customerID].usages[year][month] = amount
  }
  usage(customerID, year, month) {
    return this._data[customerID].usages[year][month]
  }
}

let customerData = new CustomerData(data)

function getCustomerData() {
  return customerData
}
function getRawDataOfCustomers() {
  return customerData.rawData
}
function setRawDataOfCustomers(args) {
  customerData = new CustomerData(args)
}

// 최상위...
let customerId = 1920

// 쓰기
// getRawDataOfCustomers()[customerId].usages[2016][1] = 100
customerData.setUsage(customerId, 2016, 1, 100)

// 읽기
function compareUsage(customerId, laterYear, month) {
  // const later = customerData[customerId].usages[laterYear][month]
  const later = getCustomerData().usage(customerId, laterYear, month)

  // const earlier = customerData[customerId].usages[laterYear - 1][month]
  const earlier = getCustomerData().usage(customerId, laterYear - 1, month)

  return { laterAmount: later, change: later - earlier }
}
```

이 방식의 가장 큰 장점은 customerData의 모든 쓰임을 명시적 API로 제공한다는 것이다. 이 클래스만 보면 데이터 사용 방법을 모두 파악할 수 잇다. 하지만 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어난다.

클라이언트가 데이터를 직접 수정하지 못하게 rawData() 메서드를 사용하여 내부 데이터를 복제해서 제공한다. 이 방법이 간단하지만 문제가 있다. 데이터 구조가 클수록 복제 비용이 커져서 성능이 느려질 수 있다. 또 다른 문제는 클라이언트가 원본을 수정한다고 착각할 수 있다는 것이다. 이럴 때는 읽기전용 프락시를 제공하거나 복제본을 동결시켜서 데이터를 수정하려 할 때 에러를 던지도록 만들 수 있다.

다른 방법은 레코드 캡슐화를 재귀적으로 하는 것으로, 할 일은 늘어나지만 가장 확실하게 제어할 수 있다. 이 방법을 적용하려면 고객 정보 레코드를 클래스로 바꾸고, 컬렉션 캡슈로하하기로 레코드를 다루는 코드를 리팩터링해서 고객 정보를 다루는 클래스를 생성한다. 그런 다음 접근자를 이용해서 갱신을 함부로 하지 못하게 만든다. 하지만 데이터 구조가 거대하면 일이 상당히 커지며, 그 데이터 구조를 사용할 일이 많지 않다면 효과도 별로 없다. 때로는 새로 만든 클래스와 게터를 잘 혼합해서, 게터는 데이터 구조를 깊이 탐색하게 만들되 원본 데이터를 그대로 반환하지 말고 객체로 감싸서 반환하는 게 효과적일 수 있다.
