# 컬렉션 캡슐하기

컬렉션 변수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 하는 경우

```javascript
class Person {
  constructor(name) {
    this._name = name
    this._courses = []
  }
  get name() {
    return this._name
  }
  get courses() {
    return this._courses
  }
  set courses(aList) {
    this._courses = aList
  }
}

class Course {
  constructor(name, isAdvanced) {
    this._name = name
    this._isAdvanced = isAdvanced
  }
  get name() {
    return this._name
  }
  get isAdvanced() {
    return this._isAdvanced
  }
}

// 클라이언트 ....

for (const name of readBasicCourseNames(filename)) {
  aPerson.courses.push(new Course(name, false))
}
```

## 컬렉션 값을 반환하지 않게 하는 방법

컬렉션 변경자 메서드를 통해 원소를 변경하도록 한다.

```javascript
class Person {
  constructor(name) {
    this._name = name
    this._courses = []
  }
  get name() {
    return this._name
  }

  get courses() {
    // 복제본 제공하는 방식으로 변경
    return this._courses.slice()
  }

  // 세터 제거하기
  // set courses(aList) {
  //   this._courses = aList
  // }

  addCourse(aCourse) {
    this._courses.push(aCourse)
  }

  removeCourse(
    aCourse,
    // 컬렉션에 없는 원소를 제거하려 할때의 대응 방식
    fnIfAbsent = () => {
      throw new RangeError()
    }
  ) {
    const index = this._courses.indexOf(aCourse)
    if (index === -1) {
      fnIfAbsent()
    } else {
      this._courses.splice(index, 1)
    }
  }
}

class Course {
  constructor(name, isAdvanced) {
    this._name = name
    this._isAdvanced = isAdvanced
  }
  get name() {
    return this._name
  }
  get isAdvanced() {
    return this._isAdvanced
  }
}

// 클라이언트 ....

for (const name of readBasicCourseNames(filename)) {
  // aPerson.courses.push(new Course(name, false))
  aPerson.addCourse(new Course(name, false))
}
```
