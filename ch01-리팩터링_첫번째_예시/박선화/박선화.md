# 리팩터링: 첫 번쨰 예시

사람은 코드의 미적 상태에 민감하다. 설계가 나쁜 시스템은 수정하기 어렵다.
원하는 동작을 수행하도록 하기위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다.
무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다.
프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

**프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.**

## 예시 코드 - 공연료 청구서 출력

> 24 페이지

다양한 연극을 외주로 받아서 공연하는 극단의 공연료 청구서를 출력하는 코드 ([statement 함수](./statement01.js))

- 장르와 관객 규모를 기초로 비용 책정
- 공연료와 별개로 포인트를 지급해서 다음 번 의뢰 시 공연료 할인

[수정할 부분]

1. 청구 내역을 HTML로 출력하는 기능
   - 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야 함 -> `statement()` 함수의 복잡도가 크게 증가
   - 이 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리 -> 중복 코드 발생
2. 장르 추가와 공연료 정책 변경에 유연한 구조
   - 연극 장르와 공연료 정책이 달라질 때마다 statement() 함수를 수정해야 함. 만약 statement()를 복사해서 별도 htmlStatement()를 만든다면 모든 수정이 두 함수에 일관되게 반영되도록 보장해야 함.

리팩터링이 필요한 이유는 바로 이러한 변경 때문이다.

## 리팩터링의 첫 단계

리팩터링의 첫 단계는 제대로된 테스트부터 마련하는 것이다. 여기서 중요한 부분은 테스트 결과를 보고하는 방식이다. 테스트는 반드시 자가진단하도록 만든다. 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면, 두 번 다 실수하지 않는 한 버그 검출기에 반드기 걸린다. 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있다. 테스트 작성에 시간이 걸리지만, 디버깅에 시간이 줄어서 전체 작업 시간은 오히려 단축된다.

### 함수 추출하기 -- statement() 함수 쪼개기

기존 예제 코드의 switch 문을 보면 한 번의 공연에 대한 요금을 계산하고 있다. 코드 조각을 별도 함수로 추출하는 방식으로 파악한 정보를 코드에 반영할 것이다. 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다.

별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다.

- [amountFor(aPerformance) 함수](./statement02.js)

리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다. 한 가지를 수정할 때마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다. 이렇게 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다.

리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

### 명확성을 높이기 위한 이름 변경

#### 첫 번째 인수인 perf를 aPerformance로 리팩터링

자바스크립트와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움된다. 매개변수 이름에 접두어로 타입 이름을 적는데, 매개변수 역할이 뚜렷하지 않을 때는 부정 관사(a/an)를 붙인다.

좋은 코드라면 하는 일이 명확히 드러나야하며, 이때 변수 이름은 커다란 역할을 한다.

#### play 변수 제거하기

- [예제 코드](./statement03.js)

aPerformance는 루프 변수에서 오기 때문에 반복문을 한 번 돌 때마다 자연스레 값이 변경된다. 하지만 play는 개별 공연(aPerformance)에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다. 이를 해결해주는 리팩터링으로는 **임시 변수를 질의 함수로 바꾸기**가 있다.

변수 인라인 하기를 적용하여 amountFor()에 함수 선언 바꾸기를 적용해서 play 매개변수를 제거할 수 있게 되었다.

이전 코드는 루프를 한 번 돌 때마다 공연을 조ㅓ회했는데 반해, 리팩터링한 코드에서는 세 번이나 조회한다. 하지만 일단 이렇게 변경해도 성능에 큰 영향은 없다. 설사 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.

지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다. 추출 작업 전에는 거의 항상 지연 변수부터 제거한다.

#### volumeCredits 변수 처리하기

- [예제 코드](./statement04.js)

### 임시 변수 제거하기

임시 변수는 나중에 문제를 일으킬 수 있다. 임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다. 따라서 임시 변수들을 제거한다.

format은 임시 변수에 함수를 대입한 형태인데, 함수를 직접 선언해 사용하도록 바꾼다.
format은 함수가 하는 일을 충분히 설명해주지 못한다. 템플릿 문자열 안에서 사용될 이름이다. 이 함수의 핵심은 화폐 단위 맞추기이다.

이름짓기는 중요하면서도 쉽지 않다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘지어야만 효과가 있다.
이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다. 바로 좋은 이름을 짓기는 쉽지 않다. 처음에는 떠오르는 최선의 이름을 사용하다가, 나중에 좋은 이름으로 바꾸는 식이 좋다.

- [예제 코드](./statement05.js)

### 반복문 쪼개기

반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다. 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다. 실제로 이번 리팩터링 전과 후의 실행 시간을 측정해보면 차이를 거의 느끼지 못할 것이다.

하지만 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 그런 경우라도 나는 개의치 않고 리팩터링한다. 잘 다듬어진 코드여야 성능 개선 작업도 훨씬 수월하기 때문이다. 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다.

따라서 리팩터링으로 인한 성능 문제에 대한 조언은 '특별한 경우가 아니라면 일단 무시하라'는 것이다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

#### volumeCredits 변수 제거하기

반복문 쪼개기로 volumeCredits 값이 누적되는 부분을 따로 빼낸다.
이어서 문장 슬라이스하기를 적용하여 volumeCredits 변수를 선언하는 문장을 반복문 바로 앞으로 옮기고, 모아진 volumeCredits 값 계산 코드를 함수로 추출하는 작업을 한 뒤 변수를 인라인한다.

- [예제 코드](./statement06.js)

volumeCredits 변수 제거하는 작업의 단계는 총 네 단계로 수행했으며, 각 단계마다 컴파일-테스트하고 로컬 저장소에 커밋했다.

1. 반복문 쪼개기로 변수 값을 누적시키는 부분을 분리한다.
2. 문장 슬라이드하기로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. 함수 추출하기로 적립 포인트 계산 부분을 별도 함수로 추출한다.
4. 변수 인라인하기로 volumeCredits 변수를 제거한다.

이와 같이 상황이 복잡해지면 단계를 작게 나누는 일을 먼저 한다. 코드가 복잡할 수록 단계를 작게 나누면 작업 속도가 빨라지기 때문이다.

## 계산 단계와 포맷팅 단계 분리하기

statement()의 HTML 버전을 만드는 작업 진행한다. 계산 코드가 모두 분리됐기 때문에 7줄에 대응하는 HTML 버전만 작성하면 된다.

이 모두를 그대로 복사해 붙이는 방식이 아닌, 텍스트 버전과 HTML 버전 함수 모두가 똑같은 계산 함수들을 사용하게 만들고 싶다.

### 단계 쪼개기

statement()의 로직을 두 단계로 나눈다. <br />
첫 번째 단계에서는 statement()에 필요한 데이터를 처리한다. 즉, 다음 단계로 전달할 중간 데이터 구조를 생성한다.<br />
두 번째 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현한다.

- [예제 코드](./statement07.js)
  함수로 추출하면서 코드량이 늘었지만, 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다. 이렇게 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다.

## 다형성을 활용해 계산 코드 재구성하기 -- 조건부 로직을 다형성으로 바꾸기

amountFor() 함수를 보면 연극 장르에 따라 계산 방식이 달라진다.

<details>
<summary>amountFor() 함수</summary>

```javascript
function amountFor(aPerformance) {
  let result = 0
  switch (aPerformance.play.type) {
    case 'tragedy': // 비극
      result = 40000
      if (aPerformance.audience > 30) {
        result += 1000 * (aPerformance.audience - 30)
      }
      break
    case 'comedy': // 희극
      result = 30000
      if (aPerformance.audience > 20) {
        result += 10000 + 500 * (aPerformance.audience - 20)
      }
      result += 300 * aPerformance.audience
      break
    default:
      throw new Error(`알 수 없는 장르: ${aPerformance.play.type}`)
  }
  return result
}
```

</details>

이런 형태의 조건부 로직은 코드 수정 횟수가 늘어날수록 골칫거리로 전락하기 쉽다. 이를 방지하려면 프로그래밍 언어가 제공하는 구조적인 요소로 적절히 보완해야 한다. 조건부 로직을 명확한 구조로 보완하는 방법은 다양하지만, 여기서는 객체지향의 핵심 특성인 다형성을 활용하는 것이 자연스럽다.

이번 작업의 목표는 상속 계층을 구성해서 희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의하는 것이다.

### 공연료 계산기 만들기

공연 관련 데이터를 계산하는 함수들로 구성된 공연료 계산 클래스(`PerformanceCalculator`) 만들기

- [예제 코드](./statement08.js)

### 조건부 로직을 다형성으로 바꾸기

- [예제 코드](./statement09.js)

- class TragedyCalculator extends PerformanceCalculator - 비극 장리 공연료 계산기 클래스
- class ComedyCalculator extends PerformanceCalculator - 희극 장리 공연료 계산기 클래스

연극 장르별 계산 코드들을 함께 묶어뒀다. 앞으로의 수정 대부분이 이 코드에서 이뤄질 것 같다면 이렇게 명확하게 분리해두면 좋다. 이제 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 createPerformanceCalculator()에 추가하기만 하면 된다.

여기서는 두 개의 amountFor()와 valumeCreditsFor()의 조건부 로직을 생성 함수 하나로 옮겼다. 같은 타입의 다형성을 기반으로 실행되는 함수가 많을수록 이렇게 구성하는 쪽이 유리하다.

자바스크립트 클래스 시스템의 멋진 점 하나가 효과를 발휘하는데, 바로 게터 메서드를 호출하는 코드와 일반적인 데이터 접근 코드의 모양이 똑같다는 점이다.

한편 계산기 인스턴스를 반환하는 방식과 각각의 출력 값으로 직접 계산하는 방식 중 하나를 선택할 때 나는 결과로 나온 데이터 구조를 누가 사용하는가를 기준으로 결정한다.

## 마치며

간단한 예였지만 함수 추출하기, 변수 인라인하기, 함수 옮기기, 조건부 로직을 다형성으로 바꾸기를 비롯한 다양한 리팩터링 기법을 선보였다.

이번 장에서는 리팩터링을 크게 세 단계로 진행했다.

1. 원본ㅎ 함수를 중첩 함수 여러 개로 나누기
2. 단계 쪼개기를 적용하여 계산 코드와 출력 코드를 분리
3. 계산 로직을 다형성으로 표현

각 단계마다 코드 구조를 보강하고, 그럴 때마다 코드가 수행하는 일이 더욱 분명하게 드러났다.

리팩터링은 대부분 코드가 하는 일을 파악하는 데서 시작한다. 그래서 코드를 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행한다. 그 결과 코드가 명확하고 이해하기 더 쉬워진다. 그러면 또 다른 개선점이 떠오르며 선순환이 형성된다.

좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다. 코드는 명확해야 한다. 코드를 수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다. 건강한 코드베이스는 생산성을 극대화하고, 고객에게 필요한 기능을 더 빠르고 저렴한 비용으로 제공하도록 해준다. 코드를 건강하게 관리하려면 프로그래밍 팀의 현재와 이상의 차이에 항상 신경 쓰면서, 이상에 가까워지도록 리팩터링해야한다.

이번 예시를 통해 배울 수 있는 점은 바로 리팩터링하는 리듬이다. 리팩터링 과정마다 각 단계를 잘게 나누고 매번 컴파일하고 테스트하여 작동하는 상태로 유지한다. 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.
