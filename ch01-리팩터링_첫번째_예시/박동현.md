# 1. 리팩터링 첫번째 예시

사람은 코드의 미적 상태에 민감함, 설계가 나쁜 시스템은 수정하기 어려움
-> 작동 방식을 더 쉽게 파악할 수 있도록 여러 함수와 프로그램 요소로 재구성하기, 프로그램 구조가 빈약하면 대체로 구조부터 바로 잡은 뒤 기능을 수정하는 편이 작업하기 수월

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

현재 구조는 연극 장르와 공연료 정책이 달라질때 마다 statement() 함수를 수정해야함!

## 2. 리팩터링의 첫 단계

**1. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드부터 마련해야함\***

> 리팩터링 하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

statement함수를 보면 switch문이 있는데, 이는 코드를 분석해서 얻는 정보임, 고로 이런식으로 파악한 정보는 내 머릿속에 기억되므로 재빨리 코드를 반영해야함.
이를 막기 위해 함수를 추출하여 그 코드가 하는 일을 설명하는 이름을 지어줌

**amountFor(aPerformance)**
동사 + 전치사 + 객체 형태
~에 대한 금액을 계산한다.

~에 해당하는것은 매개변수로 표현

```javascript
// 좋은 예
function amountFor(aPerformance) { ... }
function volumeCreditsFor(aPerformance) { ... }
function playFor(aPerformance) { ... }

// 나쁜 예, 객체지향 패턴(performance.getAmount()
function calculate(perf) { ... }
function getCredits(p) { ... }
function findPlay(performance) { ... }

// 비즈니스 도메인의 언어를 그대로 사용
function amountFor(aPerformance) {
  // "공연에 대한 금액을 계산한다"는 비즈니스 요구사항과 정확히 일치
}

// "어떤 공연이든" 같은 방식으로 처리한다는 의미
function amountFor(aPerformance) {
  // 입력이 같으면 항상 같은 결과 반환
  // 외부 상태에 의존하지 않음
}
```

먼저 별도의 함수로 뺴냈을 떄 유효범위를 벗어나는 변수를 파악하여 사용한다.

함수 반환값ㅅ에 result이름을 쓰면 그 변수의 역할을 쉽게 할 수 있음.

필자의 코딩 스타일로는 매개변수 이름에 접두어로 타입 이름을 적음, 지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정관사를 붙임

켄트백에게 배운 패턴이라고함

매개변수 중 play처럼 값이 변경되지 않는 것들은 최대한 제거하는게 좋음.

```javascript
const playFor = (aPerformance) => plays[aPerformance.playID];
```

Q. 변수 인라인은 좋은가?

리팩토링된 코드는 공연을 한 번 조회하던 기존 코드에서 세 번 조회하게됨. 허나 개선하기 수월하여 이렇게 사용한다함

## 3. 다형성을 활용해 계산 코드 재구성하기

case tragedy : return new TragedyCalculator(aPerformance, aPlay);
case comedy : return new Cornedycalculator(aPerforniance, aPlay);

와 같이 사용함

# 🧩 함수 리팩터링 체크리스트

> **목표:** 함수의 가독성, 재사용성, 유지보수성을 높이고 부수효과를 최소화한다.  
> (출처: Refactoring 2nd, Clean Code, Functional Programming)

---

## 1️⃣ 단일 책임 (Single Responsibility)

- 함수는 **한 가지 일만** 수행해야 한다.
- 이름이 “동사 + 목적어” 형태로 1줄 설명이 가능해야 함.

## 2️⃣ 순수 함수 (Purity)

- 동일한 입력 → 동일한 출력.
- 외부 상태를 변경하지 않는다.
- I/O, DOM 조작 등 부수효과는 별도 함수로 분리.

## 3️⃣ 캡슐화 (Encapsulation)

- 내부 데이터 구조나 로직을 외부에 노출하지 않는다.
- 불변 객체나 복사본을 반환.

## 4️⃣ 명확한 네이밍 (Naming)

- 이름만 봐도 **무엇을 하는지** 이해 가능해야 한다.
- `processData()` ❌ → `calculateSubtotal()` ✅

## 5️⃣ 파라미터 관리 (Parameters)

- 인자는 **3개 이하**가 이상적.
- 관련 값은 **객체로 묶기**.
- 불필요한 플래그 인자(`true/false`)는 함수 분리로 대체.

## 6️⃣ 가드 절 (Guard Clauses)

- 예외 상황은 **초반에 반환**해 중첩을 줄인다.

```js
if (!user) return;
```

## 7️⃣ 조건 분해 (Condition Decomposition)

복잡한 조건식은 의미 있는 함수로 추출.

```js
if (isHoliday() && isVip(user)) → if (isVipHoliday(user))
```

## 8️⃣ 불변성 유지 (Immutability)

변수 재할당 최소화.

객체/배열 갱신 시 스프레드({ ...obj })나 새 객체 생성.

## 9️⃣ 일관된 오류 처리 (Error Handling)

함수는 예외를 던질지, 결과 타입(Ok/Err, Result)을 반환할지 통일.

경계(모듈)에서 한 번에 변환 처리.

## 🔟 명확성 우선 (Clarity over Cleverness)

성능보다 의도와 흐름이 명확한 코드를 우선.

조기 최적화보다는 읽기 쉬운 구조를 유지.
