# 1장 리팩터링: 첫번째 예시

## 1.1 자, 시작해보자!

> 공연하는 극단이 있다.
> 공연 요청이 들어오면 장르와 관객 규모로 비용을 책정한다.
>
> 장르는 비극과 희극만 있다.
>
> 공연료와 별개로 포인트를 지급한다. (공연료 할인 가능)

plays.json

```json
{
  "hamlet": {
    "name": "hamlet",
    "type": "tragedy"
  },
  "as-like": {
    "name": "As You Like It",
    "type": "comedy"
  },
  "othello": {
    "name": "Othello",
    "type": "tragedy"
  }
}
```

공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.

invoice.json

```json
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55
      },
      {
        "playID": "as-like",
        "audience": 35
      },
      {
        "playID": "othello",
        "audience": 40
      }
    ]
  }
]
```

공연료 청구서 출력 함수

```ts
type PerformanceInfo = {
    playId: string;
    audience: number;
}
type Invoice = {
    customer: string;
    performances: PerformanceInfo[];
}

type Play = {
    name: string;
    type: string;
}
type Plays = Record<string, Play>

function statement(invoice: Invoice, plays: Plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice.customer})\n`;
  const format = new Intl.NumberFormat("en-US", { style: "currency", currency:"USD", minimumFractionDigits: 2}).format;
  
  for (let performance of inovice.performances) {
    const play = plays[performance.playID];
    let thisAmount = 0;
  
    swith (play.type) {
      case "tragedy": // 비극
        thisAmount = 40000;
        if(performance.audience > 30) {
          thisAmount += 10000 * (performance.audience - 30);
        }
        break;
      case "comedy": // 희극
        thisAmount = 30000;
        if(performance.audience > 20) {
          thisAmount += 10000 + 500 * (performance.audience - 20);
        }
        thisAmount += 300 * performance.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트를 적립한다.
    volumeCredits += Math.max(performance.audience - 30, 0);

    // 희극 관객 5명마다 추가 포인트를 지급한다.
    if("comedy" === play.type) volumeCredits += Math.floor(performance / 5);

    // 청구내역을 출력한다.
    result += ` ${play.name}: ${format(thisAmount/100)} (${performance.audience}석)\n`;
    totalAmount+= thisAmount;
  }

  result += `총액: ${format(totalAmount/100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

반환 결과:

> 청구내역 (고객명: BigCo) <br/>
> hamlet: $650 55석 <br/>
> As You Like It: $580 35석 <br/>
> Othello: $500 40석 <br/>
> 총액: $1730 <br/>
> 적립 포인트: 47점 <br/>

## 1.2 예시 프로그램을 본 소감

솔직히 이정도면 그럭저럭 쓸만해 보인다.
하지만, 이런 코드가 수백 줄 짜리 프로그램의 일부라면 이야기가 달라지겠지.

프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로 불평하는 것은 프로그램의 구조를 너무 미적인 기준으로만 판단하는게 아닐까?
컴파일러는 코드가 지저분하든 아니든 개의치 않아 하지만, 사람은 코드의 미적 상태에 민감하다.

내가 직접 수정해야되기 때문.. 혹은 훗날 누군가가 수정해야 하기 때문..

> "프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다."

### 🚀 여기서 수정할 Point

1. 청구 내역을 HTML로 출력하는 기능
2. 연극 장르와 공연료 정책이 달라져도 유연하게 대응

리팩터링이 필요한 이유는 바로 **'변경'** 때문이다!

누군가 코드를 읽지 않도록 방치되어 있다면 리팩터링 하지 않아도 굳이? 라고 할 수 있지만,
다른 사람이 읽고 이해할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 할 수 있다.

## 1.3 리팩터링의 첫 단계

**🧪 테스트 코드..**

> "리팩터링 하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다."

저자는 리팩터링 시 테스트에 상당히 의지한다고 한다.
내가 저지른 실수로 부터 보호해주는 안전장치이기 떄문이다.

