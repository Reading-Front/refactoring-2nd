### 1.2 예시 프로그램을 본 소감

> 프로그램이 새로운 기능을 추 가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다

### 1.3 리팩터링의 첫 단계

> 리팩터링하기 전에 제대로 된 테스트부터 마련한댜ㅏ. 테스트는 반드시 자가진단하도록 만든다

- 나는 리팩터링 시 텟트에 상당히 의지한다. 내가 저지른 실수를 보호해주는 버그 검출기 역할을 해주기 때문이다

### 1.4 statement() 함수 쪼개기

- 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다

- 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다

- 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다

- 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내서 개선한다

```js
const perf = performance;
const play = plays[perf.playId];
```

- 다른 곳에서도 `plays[perf.playId]`를 반복해서 쓰면 코드가 점점 **“데이터 구조 의존적”**으로 변하게 된다.

- 리팩터링 후

```js
function playFor(aPerformance) {
  return plays[aPerformance.playId];
}
```

- `plays[aPerformance.playId]`는 “연극을 찾는다”는 의미가 코드를 읽는 사람에게 직접 드러나지 않음.

이제 `playFor(perf)`로 호출하게 되면, `play`가 어떻게 구해지는지에 대한 **구체적인 로직(plays[perf.playId])**이 감추고 도메인 의미를 바로 보여줌.

- 한 줄짜리 단순 참조를 함수로 감싸면 성능은 미세하게 떨어짐 (하지만 무시해도 될 수준)

### 1.10 마치여

> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다
