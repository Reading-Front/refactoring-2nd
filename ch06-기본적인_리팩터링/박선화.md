# 6장 기본적인 리팩터링

가장 많이 사용하는 리팩터링은 추출하기이다. 추출은 결국 이름 짓기이다. <br />
함수 선언바꾸기는 함수의 이름을 변경할 때 가장 많이 쓰인다.
변수 이름 바꾸기는 변수 캡슐화하기와 관련이 깊다.

인수를 묶을 때는 매개변수 객체 만들기를 적용하고, 함수를 그룹으로 묶을 때는 여러 함수를 클래스로 묶기를 이용한다. 또 다른 방법으로 읽기 전용 데이터를 다룰 때는 여러 함수를 변환 함수로 묶기를 적용한다. 더 나아가, 묶은 모듈들의 작업 처리 과정을 명확한 단계로 구분 짓는 단계 쪼개기를 적용할 때도 많다.

## (1) 함수 추출하기

코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다. 코드를 언제 독립된 함수를 묶어야 할지의 기준은 '목적과 구현을 분리'하는 방식이 가작 합리적이다. 코드를 보고 무슨 일을 하는지 파악하는 데 오래 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다. 이러한 원칙을 적용한 뒤로는 함수르 ㄹ아주 짧게, 대체로 단 몇 줄만 담도록 작성한다. 짧은 함수의 이점은 이름을 잘 지어야만 발휘되므로 이름 짓기에 신경을 쓴다.

함수로 뽑아서 목적이 더 잘 드러나는 이름을 붙일 수 있다면 추출하고, 이름이 떠오르지 않는다면 함수로 추출하면 안된다는 신호다. 하지만 이름부터 짓고 시작할 필요는 없다. 일단 함수로 추출하고 다시 인라인해도 된다. 그 과정에서 뭔가를 깨달은 게 잇다면 시간 낭비는 아니다.

때로는 추출한 코드에서 값을 수정하는 지역 변수가 너무 많을 수 있다. 이럴 때는 함수 추출을 멈추고, 변수 쪼개기나 임시 변수를 질의 함수로 바꾸기와 같은 다른 리팩터링을 적용해서 변수를 사용하는 코드를 단순하게 바꿔보단. 그런 다음 함수 추출을 다시 시도한다.

함수에서 값을 반환할 변수가 여럭 개라면 주로 추출할 코드를 다르게 재구성하는 방향으로 처리한다. 함수가 값 하나만 반환하는 방식을 선호하기 때문에 각가을 반환하는 함수 여러 개로 만든다. 굳이 한 함수에서 여러 값을 반환해야 한다면 값들을 레코드로 묶어서 반환해도 되지만, 임시 변수 추출 작업을 다른 방식으로 처리하는 것이 나을 때가 많다. 여기서는 임시 변수를 질의 함수로 바꾸거나 변수르 ㄹ쪼개는 식으로 처리하면 좋다.

## (2) 함수 인라인하기

목적이 분명히 드러나는 이름의 짧은 함수를 권하지만, 때로는 함수 본문이 이름만큼 명확한 경우도 있다. 이럴 때는 그 함수를 제거한다.

간접 호출은 유용할 수도 있지만 쓸데없는 간접 호출은 거슬릴 뿐이다. 간접호출을 너무 과하기 쓰는 코드도 흔한 인라인 대상이다. 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게 얽혀 있으면 인라인해버린다.

**절차**

1. 다형 메서드이지 확인하고, 서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다.
2. 인라인할 함수르 ㄹ호출하는 곳을 모두 찾는다.
3. 각 호출문을 함수 본문으로 교체한다.
4. 하나씩 교체할 때마다 테스트한다.
5. 원래 함수를 삭제한다.

실수하지 않으려면 한 번에 한 문장씩 옮기는 것이 좋다. 잘라내서, 붙이고, 다듬는 방식으로 간단히 처리한다. <br />
핵심은 항상 단계를 잘게 나눠서 처리하는 데 있다. 어느 정도 자신감이 붙으면 다시 작업을 크게 묶어서 처리한다. 그러다 테스트가 실패하면 가장 최근의 정상 코드로 돌아온 다음, 단계를 잘게 나눠서 다시 리팩터링한다.

## (3) 변수 추출하기

표현식이 너무 복잡해서 이해하기 어려울 때 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다. 그러면 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어서 코드의 목적을 훨씬 명확하게 드러낼 수 있다.

이름을 붙이기로 했다면 그 이름이 들어갈 문맥도 살펴야 한다. 현재 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋다. 그러나 함수르 ㄹ벗어난 넓은 문맥에서까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생각해야 한다. 다시 말해 변수가 아닌 함수로 추출해야 한다.

```javascript
function price(order) {
  return (
    order.quantity * order.itemPrice -
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
    Math.min(order.quantity * order.itemPrice * 0.1, 100)
  )
}

function refactoredPrice(order) {
  // 가격(price) = 기본 가격(base price) - 수량 할인(quantity discount) + 배송비(shipping)
  const basePrice = order.quantity * order.itemPrice
  const quantityDiscount =
    Math.max(0, order.quantity - 500) * order.itemPrice * 0.05
  const shipping = Math.min(basePrice * 0.1, 100)
  return basePrice - quantityDiscount + shipping
}
```

## (4) 변수 인라인하기

변수는 함수 안에서 표현식을 가리키는 이름으로 쓰인다. 하지만 그 이름이 원래 표현식과 다를 바 없을 때도 있다. 또 변수가 주변 코드를 리팩터링하는 데 방해가 되기도 한다. 이럴 때는 그 변수를 인라인 하는 것이 좋다.

## (5) 함수 선언 바꾸기

함수는 프로그램을 작은 부분으로 나누는 주된 수단으로, 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며 실질적으로 구성 요소를 조립하는 연결부 역할을 한다. 연결부에서 가장 중요한 요소는 함수의 이름이다. 이름이 좋으면 함수의 구현 코드를 살펴볼 필요 없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있다.

> 좋은 이름을 떠올리는 데 효과적인 방법이 하나 있다. 바로 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다 보면 주석이 멋진 이름으로 바뀌어 되돌아올 때가 있다.

함수 선언 바꾸기는 간단한 절차일 때도 있지만, 더 세분화된 '마이그레이션 절차'가 적합한 경우도 많다. 따라서 먼저 변경 사항을 살펴보고 함수 선언과 호출문들을 단번에 고칠 수 있을 지 가늠해본다. 가능할 것 같다면 간단한 절차를 따른다. 마이그레이션 절차를 적용하면 호출문들을 점진적으로 수정할 수 있다.

호출하는 곳이 많거나, 호출 과정이 복잡하거나, 호출 대상이 다형 메서드거나, 선언을 복잡하게 변경할 때는 마이그레이션 절차를 따라야 한다.

변경할 게 둘 이상이면 나눠서 처리하는 편이 나을 때가 많다. 따라서 이름 변경과 매개변수 추가를 모두 하고 싶다면 각각을 독립적으로 처리하자.

**마이그레이션 절차**

1. 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
2. 함수 본문을 새로운 함수로 추출한다.
3. 추출한 함수에 매개변수를 추가해야 한다면 '간단한 절차'를 따라 추가한다.
4. 테스트한다.
5. 기존 함수를 인라인한다.
6. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 일므으로 되돌린다.
7. 테스트한다.

### 예시 - 매개변수 추가하기

Book 클래스에 예약기능이 구현되어 있는 상태에서 예약 시 우선순위 큐를 지원하라는 요구가 추가되어 addReservation()을 호출할 때 예약 정보를 일반 큐에 넣을지 우선순위 큐에 넣을지를 지정하는 매개 변수를 추가하려 한다.

```javascript
class Book {
  constructor() {
    this._reservations = []
  }

  addReservation(customer) {
    // 기존 함수 내용
    // this._reservations.push({ customer })

    this.zz_addReservation(customer)
  }

  zz_addReservation(customer, isPriority) {
    /**
     * javascript로 프로그래밍한다면, 호출문을 변경하기 전에 어셔션을 추가하여 호출하는 곳에서 새로 추가한 매개변수를 사용하는지 확인한다.
     */
    assert(isPriority === true || isPriority === false)
    this._reservations.push({ customer })
  }
}
```

1. 기존 함수의 본문을 새 함수로 추출하고 임시 이름을 붙인다.
2. 새 함수의 선언문과 호출문에 원하는 매개변수를 추가한다.
3. 호출문을 변경하기 이전에 어서션을 추가하여 호출하는 곳에서 새로 추가한 매개변수를 실제로 사용하는지 확인한다.
   호출문을 수정하는 과정에서 실수로 새 매개변수를 빠뜨린 부분을 찾는 데 도움된다.
4. 기존 함수를 인라인 하여 호출 코드들이 새 함수를 이용하도록 고친다.
5. 새 함수의 이름을 기존 함수로 바꾼다.

## (6) 변수 캡슐화하기

데이터는 함수보다 다루기가 까다로운데, 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다. <br />
유효범위가 넓어질수록 다루기가 어려워지며, 전역 데이터가 골칫거리인 이유도 바로 여기에 있다. <br />
그래서 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독접하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다. 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것이다.

**데이터 캡슐화**는 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다. 데이터의 유효범위가 넓을 수록 캡슐화해야 한다. 레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나 변경할 때마다 최대한 캡슐화한다. 그래야 자주 사용하는 데이터에 대한 결합도가 높아지는 일을 막을 수 있다.

```javascript
// defaultOwner.js 파일
let defaultOwnerData = { firstName: '마틴', lastName: '파울러' }

export function getDefaultOwner() {
  // return defaultOwnerData
  // 변수에 담긴 내용을 변경하는 행위를 제어할 수 있게 캡슐화하고 싶다면 게터가 데이터의 복제본을 반환하도록 수정한다.
  return Object.assign({}, defaultOwnerData)
}

export function setDefaultOwner(arg) {
  defaultOwnerData = arg
}

// main.js 파일
import { getDefaultOwner, setDefaultOwner } from './defaultOwner.js'
```

## (7) 변수 이름 바꾸기

이름을 잘못 지을 때가 많다. 고민을 충분히 하지 않아서거나, 문제에 대한 이해도가 낮아서거나, 사용자의 요구가 달라져서 프로그램의 목적이 변해 그럴 때도 있다.

변수 이름 바꾸기의 간단한 예는 임시 변수나 인수처럼 유효범위가 함수 하나로 국한된 변수다.

함수 밖에서도 참조할 수 있는 변수라면, 변수 캡슐화하기로 처리한다.

## (8) 매개변수 객체 만들기

데이터 무리를 발견하면 데이터 구조 하나로 모아준다. 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다. 함수에 전달할 경우 매개변수 수가 줄어들며, 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.

리팩터링의 진정한 힘은 코드를 더 근본적으로 바꿔준다는 데 있다. 이런 데이터 구조를 새로 발견하면 이 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성한다. 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만드느 것이다. 이 과정에서 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을 다시 그릴 수도 있다.

## (9) 여러 함수를 클래스로 묶기

클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. 클래스는 객체 지향 언어의 기본인 동시에 다른 패러다임 언어에도 유용하다.

공통 데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리를 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 또한 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다. 이 리팩터링은 이미 만들어진 함수들을 재구성할 때는 물론, 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메서드로 뽑아내는 데도 좋다.

함수를 한데 묶는 또 다른 방법으로 여러 함수를 변환 함수로 묶기도 있다. 클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 것이다.

## (10) 여러 함수를 변환 함수로 묶기

데이터를 입력 받아서 여러 가지 정보르 ㄹ도출하곤 한다. 이렇게 도출된 정보는 여러 곳에서 사용될 수 있는데, 이런 도출 작업들을 한데로 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.

이런 방법으로 사용되는 변환 함수는 원본 데이터를 입력받아 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다. 이렇게 해두면 도출 과정을 검출할 일이 생겼을 때 변환 함수만 살펴보면 된다.

여러 함수르 클래스로 묶기로 처리해도 된다. 다만 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있다.

여러 함수를 한데 묶는 이유 하나느 도출 로직이 중복되는 것을 피하기 위해서다. 이 로직을 함수로 추출해도 같은 효과를 볼 수 있지만, 데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수르 ㄹ발견하기 어려울 때가 많다. 변환 함수(또는 클래스)로 묶으면 이런 함수들을 쉽게 찾아 쓸 수 있다.

## (11) 단계 쪼개기

TODO: 214p
