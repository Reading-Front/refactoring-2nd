# 6장. 기본적인 리팩터링

## 6.1 함수 추출하기
<img width="1000" height="350" alt="Screenshot 2025-11-16 at 19 03 27" src="https://github.com/user-attachments/assets/66c1d82c-a997-4fef-8937-29dd5a09b568" />

여기서의 함수는 객체 지향 언어의 메서드나 프로시저, 서브루틴에도 동일 적용됨.

🔎 코드를 언제 독립된 함수로 묶어야 할까?
- 길이 (가독성)
- 재사용성

**목적과 구현을 분리**
- 코드를 보고 무슨 일을 하는지 파악하는데 한참 걸리면 그 부분을 함수로 추출한 뒤 '무슨 일' 에 걸맞는 이름을 지어준다.
- 함수를 아주 짧게, 대체로 단 몇줄만 담도록 작성하는 습관 (파이브 라인스 오브 코드)

함수 호출이 많아지면 성능 저하가 될꺼라는 오해에 대하여
- 함수가 짧으면 캐싱하기 쉽고, 컴파일러 최적화에 유리하다
- 성능 최적화 일반 지침
  - 첫번째. 하지 마라
  - 두번째. 아직 하지 마라

 이름만 잘 지어도 80% 성공

 1) '어떻게'가 아닌 '무엇을' 하는지가 드러나는 함수명 짓기
 2) 추출한 코드를 원본 함수에서 복사 + 새로 만든 함수에 붙여넣기
 3) 원래 함수에서 추출할 때 지역변수를 참조하거나, 유효범위를 벗어나는 변수 체크하고 있으면 매개변수로 넘겨주기
 4) 변수를 다 처리했다면 컴파일한다.
 5) 원래 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꿈
 6) 테스트
 7) 인라인 코드를 함수 호출로 바꾸기

예시
```js
function printOwing(invoice) {
  let outstanding = 0;

  // 배너 프린팅
  console.log("*****************")
  console.log("**** 고객 채무 ****")
  console.log("*****************")

  // 미해결 채무 계산
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일 기록
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);

  // 세부사항 출력
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

```js
const printBanner = () => {
  console.log("*****************")
  console.log("**** 고객 채무 ****")
  console.log("*****************")
}

const countOutStanding = (orders)=> {
  let result = 0;
  for (const o of orders) {
    result += o.amount;
  }

  return result;
}


const recordDueDate = (invoice) => {
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
}

// 지역변수 사용할 때 - 지역변수 2개를 매개변수로 받는 함수로 추출
const printDetails = (invoice, outstanding) => {
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

## 6.2 함수 인라인 하기

<img width="753" height="259" alt="Screenshot 2025-11-16 at 20 15 46" src="https://github.com/user-attachments/assets/7db87bf4-8f40-4a5a-8a09-48b68c23d109" />

목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권장한다.
그래야 코드가 명료해지고, 이해하기 쉬워지기 때문이다,

하지만, 때로는 **함수 본문이 이름만큼 명확한 경우**도 있다.

1) 다형 메서드인지 확인
  - 서브 클래스에서 오버라이드 하는 메서드를 인라인 하면 안됨.
2) 인라인할 함수를 호출하는 곳을 모두 찾기
3) 각 호출문을 함수 본문으로 교체
4) 하나씩 교체할 때마다 테스트
5) 함수 정의(원래 함수) 삭제

```js
function reportLines(aCustomer) {
  const lines = [];
  gatherCustomerData(lines, aCustomer);
  return lines;
}

function gatherCustomerData(out, aCustomer) {
  out.push(["name", aCustomer.name]);
  out.push(["location", aCustomer.location]);
}

function reportLines(aCustomer) {
  const lines = [];
  lines.push(["name", aCustomer.name]);
  lines.push(["location", aCustomer.location]);
  return lines;
}

```

## 6.3 변수 추출하기


<img width="490" height="111" alt="Screenshot 2025-11-16 at 20 22 14" src="https://github.com/user-attachments/assets/bfbb2c19-8ffa-4e51-8da5-1d65a749af16" />

표현식이 너무 복잡해서 이해하기 어려울 떄가 있다.
그럴 때는 지역변수를 활용하면 표현식을 사람이 이해하기 쉬운 변수로 쪼개어, 문맥을 한눈에 파악하게 만들 수 있다.

+) 디버깅에도 도움이 됨.
breaking point를 찍어서 값들을 순차적으로 확인할 수 있기 때문

1) 추출하려는 표현식의 부작용은 없는지 확인
2) 불변 변수 선언, 이름을 붙일 표현식의 복제본 대입
3) 원본 표현식을 새로 만든 변수로 교체
4) 테스트
5) 표현식을 여러곳에서 사용할 경우, 새로 만든 변수로 모두 교체 / 하나 교체할 때마다 테스트

```js
function price(order) {
  // 가격 = 정가 - 수량 할인 + 배송비
  return order.quantity * orderItemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
  Math.max(order.quantity * order.itemPrice * 0.1, 100);
}

const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrcie * 0.05;
const shipping = Math.max(basePrice * 0.1, 100);

//to-be
function price(order) {
  // 가격 = 정가 - 수량 할인 + 배송비
  return basePrice - quantityDiscount + shipping
}
```

## 6.4 변수 인라인하기

<img width="570" height="198" alt="Screenshot 2025-11-16 at 21 14 31" src="https://github.com/user-attachments/assets/03c1c310-9e7e-4c8c-8ce3-f2d9ae365201" />


대입문(assignment)을 점진적으로 변수로 치환하면서 부작용을 제거한다.

1) 대입문의 오른쪽 표현식이 부작용을 일으키지 않는지 확인한다.
2) 해당 값을 임시 변수로 만들고 테스트한다.
3) 그 변수를 처음 사용하는 코드부터 대입문 우변으로 교체해 간다.
4) 교체할 때마다 테스트한다.
5) 모든 사용처를 교체한 뒤 변수 선언문과 기존 대입문을 삭제하고 마지막으로 테스트한다.

값을 임시 변수로 추출 → 단계적으로 치환 → 매 단계 테스트 → 원본 제거

## 6.5 함수 선언 바꾸기

<img width="552" height="279" alt="Screenshot 2025-11-16 at 21 17 47" src="https://github.com/user-attachments/assets/c4561964-0c22-4563-902a-d22a15f4e5e4" />


함수의 역할과 ‘좋은 이름’의 중요성

- 함수는 프로그램을 작은 단위로 나누어 연결하는 구조적 요소이며, 잘 정의하면 유지보수가 쉬워지고 잘못 정의하면 변경이 어렵다.
- 연결부에서 가장 중요한 것은 **함수 이름**이다.

 > - 이름이 명확하면 구현을 보지 않아도 무슨 일을 하는지 직관적으로 알 수 있다.
 > - 하지만 적절한 이름을 한 번에 떠올리기 어렵기 때문에 잘못된 이름을 발견하면 **즉시 바꾸는 습관**이 중요하다.
 > - 잘못된 이름을 방치하면 혼란이 쌓인다.

매개변수 역시 인터페이스의 일부

- 매개변수는 함수가 외부와 소통하는 방식으로, 어떤 정보를 넣을지 정의한다.
- 매개변수를 어떻게 설정하느냐에 따라 함수의 활용 범위가 크게 달라진다.

  > - 전화번호 포매팅 예시처럼, 매개변수의 범위를 넓히면 더 재사용하기 좋은 함수가 된다.
  > - 반대로 필요 이상으로 매개변수를 받지 않도록 하여 모듈 간 결합을 줄일 수도 있다.

정답은 없지만 일관된 판단 기준이 필요

- 매개변수를 얼마나 넣을지에 대한 절대적인 정답은 없다.
- 하지만 시간이 지나 흐름을 더 잘 이해하게 되면 함수 인터페이스를 개선할 타이밍이 온다.
- 중요한 것은 리팩터링과 함께 **함수 이름과 매개변수를 지속적으로 개선하려는 태도**다.


함수 이름이 모호하거나 역할을 정확히 표현하지 못하는 경우, 즉시 명확한 이름으로 교체해야 한다.
이때 변경이 단순한지(호출 지점이 적음) 혹은 여러 모듈에 걸쳐 있는지에 따라 절차가 달라진다.


###  간단한 절차 (Simple Rename)

호출 위치가 적고 영향 범위가 작을 때 적용한다.


1) 함수 선언부를 수정
2) 기존 함수를 호출하는 지점을 모두 새 이름으로 교체
3) 테스트


```js
function circum(radius) {
  return 2 * Math.PI * radius;
}

// Step 1: 이름 변경
function circumference(radius) {
  return 2 * Math.PI * radius;
}

// Step 2: 호출부 교체
const result = circumference(3);
```

### 마이그레이션 절차 (Migration Rename)

함수가 **공개 API** 역할을 하거나 호출 지점이 매우 많을 때 사용한다.
기존 호출부를 한 번에 모두 바꾸기 어려운 상황에서 특히 유용하다.

1) 새 이름의 함수를 새로 정의 (구현은 기존 함수 호출)
2) 기존 함수를 호출하는 호출부를 하나씩 새 함수로 교체
3) 충분히 교체되면 기존 함수를 제거
4) 테스트

```js
function circum(radius) {
  return 2 * Math.PI * radius;
}

// Step 1: 새 함수 추가 (구현은 기존 함수 호출)
function circumference(radius) {
  return circum(radius);
}

// Step 2: 호출부를 점진적으로 변경
const len = circumference(4);

// Step 3: 모든 호출부 변경 완료 후 기존 함수 제거
function circumference(radius) {
  return 2 * Math.PI * radius;
}
```


매개변수 추가하기

매개변수는 함수의 ‘외부 인터페이스’를 표현한다.
기능 요구사항이 바뀌어 새로운 정보가 필요해지면 매개변수를 수정해야 한다.

Book 클래스에 예약 기능이 있어 `addReservation(customer)`를 호출하고 있다.
이제 ‘예약 우선순위’를 추가해야 하므로 매개변수 `isPriority`를 추가한다.


### 단순/짧은 절차

호출부가 적을 때는 바로 매개변수를 추가할 수 있다.

```js
addReservation(customer) {
  this._reservations.push(customer);
}

// After
addReservation(customer, isPriority) {
  this._reservations.push(customer);
}
```

### 마이그레이션 절차 (Migration Parameter Change)

호출부가 많거나 다른 모듈까지 퍼져 있을 때 안전하게 변경하는 단계적 절차다.

1) 새 함수 정의 (임시 이름 사용)
2) 기존 함수 내부에서 **새 함수 호출로 위임**
3) 호출부를 하나씩 새 함수로 바꾼다
4) 모든 호출부 변경 후 **기존 함수 삭제**, 새 함수를 기존 이름으로 변경

```js
addReservation(customer) {
  this._reservations.push(customer);
}
```

1) 새 함수 생성(임시)
```js
addReservation(customer) {
  this.zz_addReservation(customer, false);
}

zz_addReservation(customer, isPriority) {
  this._reservations.push(customer);
}
```

2) 호출부 마이그레이션

```js
addReservation(customer);

// After
zz_addReservation(customer, false);
```

테스트하며 하나씩 교체

3) 모든 호출부 변경 완료 → 기존 함수 제거 + 이름 복구

```js
addReservation(customer, isPriority) {
  this._reservations.push(customer);
}
```

---

### 매개변수를 속성으로 바꾸기 (Extract Parameter → Use Object Property)

> 상황: 고객의 주소 state만 넘기던 함수를 고객 객체 전체를 받도록 변경하고 싶다.

1) 새 함수 만들기

```js
function inNewEngland(aCustomer) {
  return ["MA", "CT", "ME", "VT", "NH", "RI"].includes(aCustomer.address.state);
}
```


2) 호출부 점진적 교체

```js
const newEnglanders = someCustomers.filter(c => xxNEWinNewEngland(c.address.state));

// After
const newEnglanders = someCustomers.filter(c => inNewEngland(c));
```


3) 모든 호출부 변경 완료 후 기존 함수 삭제

```js
function inNewEngland(stateCode) {
  return ["MA", "CT", "ME", "VT", "NH", "RI"].includes(stateCode);
}
// → 삭제
```
