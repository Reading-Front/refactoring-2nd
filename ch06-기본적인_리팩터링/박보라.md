# 6장. 기본적인 리팩터링

## 6.1 함수 추출하기
<img width="1000" height="350" alt="Screenshot 2025-11-16 at 19 03 27" src="https://github.com/user-attachments/assets/66c1d82c-a997-4fef-8937-29dd5a09b568" />

여기서의 함수는 객체 지향 언어의 메서드나 프로시저, 서브루틴에도 동일 적용됨.

🔎 코드를 언제 독립된 함수로 묶어야 할까?
- 길이 (가독성)
- 재사용성

**목적과 구현을 분리**
- 코드를 보고 무슨 일을 하는지 파악하는데 한참 걸리면 그 부분을 함수로 추출한 뒤 '무슨 일' 에 걸맞는 이름을 지어준다.
- 함수를 아주 짧게, 대체로 단 몇줄만 담도록 작성하는 습관 (파이브 라인스 오브 코드)

함수 호출이 많아지면 성능 저하가 될꺼라는 오해에 대하여
- 함수가 짧으면 캐싱하기 쉽고, 컴파일러 최적화에 유리하다
- 성능 최적화 일반 지침
  - 첫번째. 하지 마라
  - 두번째. 아직 하지 마라

 이름만 잘 지어도 80% 성공

 1) '어떻게'가 아닌 '무엇을' 하는지가 드러나는 함수명 짓기
 2) 추출한 코드를 원본 함수에서 복사 + 새로 만든 함수에 붙여넣기
 3) 원래 함수에서 추출할 때 지역변수를 참조하거나, 유효범위를 벗어나는 변수 체크하고 있으면 매개변수로 넘겨주기
 4) 변수를 다 처리했다면 컴파일한다.
 5) 원래 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꿈
 6) 테스트
 7) 인라인 코드를 함수 호출로 바꾸기

예시
```js
function printOwing(invoice) {
  let outstanding = 0;

  // 배너 프린팅
  console.log("*****************")
  console.log("**** 고객 채무 ****")
  console.log("*****************")

  // 미해결 채무 계산
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일 기록
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);

  // 세부사항 출력
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

```js
const printBanner = () => {
  console.log("*****************")
  console.log("**** 고객 채무 ****")
  console.log("*****************")
}

const countOutStanding = (orders)=> {
  let result = 0;
  for (const o of orders) {
    result += o.amount;
  }

  return result;
}


const recordDueDate = (invoice) => {
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
}

// 지역변수 사용할 때 - 지역변수 2개를 매개변수로 받는 함수로 추출
const printDetails = (invoice, outstanding) => {
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

## 6.2 함수 인라인 하기

<img width="753" height="259" alt="Screenshot 2025-11-16 at 20 15 46" src="https://github.com/user-attachments/assets/7db87bf4-8f40-4a5a-8a09-48b68c23d109" />

목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권장한다.
그래야 코드가 명료해지고, 이해하기 쉬워지기 때문이다,

하지만, 때로는 **함수 본문이 이름만큼 명확한 경우**도 있다.

1) 다형 메서드인지 확인
  - 서브 클래스에서 오버라이드 하는 메서드를 인라인 하면 안됨.
2) 인라인할 함수를 호출하는 곳을 모두 찾기
3) 각 호출문을 함수 본문으로 교체
4) 하나씩 교체할 때마다 테스트
5) 함수 정의(원래 함수) 삭제

```js
function reportLines(aCustomer) {
  const lines = [];
  gatherCustomerData(lines, aCustomer);
  return lines;
}

function gatherCustomerData(out, aCustomer) {
  out.push(["name", aCustomer.name]);
  out.push(["location", aCustomer.location]);
}

function reportLines(aCustomer) {
  const lines = [];
  lines.push(["name", aCustomer.name]);
  lines.push(["location", aCustomer.location]);
  return lines;
}

```

## 6.3 변수 추출하기


<img width="490" height="111" alt="Screenshot 2025-11-16 at 20 22 14" src="https://github.com/user-attachments/assets/bfbb2c19-8ffa-4e51-8da5-1d65a749af16" />

표현식이 너무 복잡해서 이해하기 어려울 떄가 있다.
그럴 때는 지역변수를 활용하면 표현식을 사람이 이해하기 쉬운 변수로 쪼개어, 문맥을 한눈에 파악하게 만들 수 있다.

+) 디버깅에도 도움이 됨.
breaking point를 찍어서 값들을 순차적으로 확인할 수 있기 때문


