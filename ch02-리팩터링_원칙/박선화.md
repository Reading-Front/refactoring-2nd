# 2장 리팩터링 원칙

## 리팩터링 정의

리팩터링은 명사로도 쓸 수 있고, 동사로도 쓸 수 있다.

- 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

코드를 정리하는 작업이 리팩터링이 아니다. 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 리팩터링 하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

'기능 추가'와 '리팩터링'을 자주 번갈아가면서 작업하더라도 이 둘의 작업 방식의 차이를 분명하게 인식해야 한다.

## 리팩터링 하는 이유

- 리팩터링함면 소프트웨어 설계가 좋아진다.

  리팩터링하지 않으면 소프트웨어의 내부 설계가 썩기 쉽다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

  중복 코드 제거는 설계 개선 작업의 중요한 축을 차지한다. 코드량이 줄면 수정하는 데 드는 노력이 줄어들고, 이해해야 할 코드량도 줄어든다. 또한 모든 콛;ㅡ가 언제나 고유한 일을 수행함을 봊낭할 수 있으며, 이는 바람직한 설계의 핵심이다.

- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

  리팩터링으로 코드의 목적이 더 잘 드러나게, 의도를 더 명확하게 전달하도록 개선할 수 있다.

- 리팩터링하면 버그를 쉽게 찾을 수 있다.

- 리팩터링하면 프로그램밍 속도를 높일 수 있다.

  내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수도 있다. 그러나 기존 코드를 최대한 활용할 수 있으므로 새 기능 또한 더 빨리 추가할 수 있게 된다.

  내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다. 이를 설계 지구력 가설이라고 부른다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

## 언제 리팩터링 해야 할까?

3의 법칙

1. 처음엔 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면 일단 계속 진행한다.
3. 비슷한 일을 세 번 진행하게 되면 리팩터링 한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다. 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 나는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

- 조건부 로직의 구조가 이상하지 않은지
- 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않았는지도 살펴본다.
- 어떤 역할을 하는지 적절한 이름으로 되어 있는지
- 이해하기 너무 긴 함수는 아닌지

### 쓰레기 줍기 리팩터링

일을 비효율적으로 처리하는 모습을 발견할 때가 있다.
로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.

### 계획된 리팩터링과 수시로 하는 리팩터링

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 리팩터링 시간을 일정에 따로 잡는 것이 아니라, 대부분 리팩터링을 다른 일을 하는 중에 처리한다. 물론 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 긴으을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.

### 오래 걸리는 리팩터링

- 라이브러리를 새 것으로 교체하는 작업
- 일부 코드를 다른 팀과 공유하기 위해 컴포넌트 빼내는 작업
- 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업
- 등등

오래 걸리는 작업이더라도 팀 전체가 리팩터링에 매달리기 보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.

### 코드 리뷰에 리팩터링 활용하기

코드 리뷰를 정기적으로 수행하는 조직도 있다. 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다. 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다. 다른 사람의 아이디어를 얻을 수도 있다.

내가 경험한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 페어 프로그래밍이 된다.

### 리팩터링하지 말아야 할 때

리팩터링하면 안 되는 상황도 있다. 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다. 그래서 이 판단에 대해서는 한 마디 조언으로 표현하기는 어렵다.

## 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

대대적인 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다. 이럴 때는 경험을 잘 발휘에서 결정한다.

### 코드 소유권

리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 준다. 함수를 호출하는 코드의 코드의 소유자가 다른 팀이라서 나에게는 권한이 없을 수 있다. 또는 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지는 고사하고, 실제로 쓰이기나 하는지조차 모를 수 있다. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.

### 브랜치

현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 맡아서 작업하다가, 결과물이 어느정도 쌓이면 마스터 브랜치에 통합해서 다른 팀원과 공유하는 것이다. 이렇게 함면 기능 전체를 한 브랜치에만 구현해놓고, 프로덕션 버전으로 릴리즈할 때가 돼서야 마스터에 통합하는 경우가 많다.

이러한 기능 브랜치 방식을 사용하면 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 카스터를 개인 브랜치로 수시로 리베이스하거나 머지한다. 하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다.

머지와 통합을 명확히 구분한다. 마스터 브랜치로 '머지'하는 작업은 단방향이다. 브랜치만 바뀌고 마스터는 그대로다. 반면, '통합'은 마스터를 개인 브랜치로 가져와서(pull해서) 작업한 결과를 다시 마스터에 올리는(push)하는 양방향 처리를 뜻한다. 그래서 마스터와 브랜치가 모두 변경된다. 누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다. 통합한 뒤에는 내 브랜치에 머지하기 상당한 노력이 들 수 있다. 이 때문에 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다. 나와 같은 사람들은 더 짧아야 한다고 주장한다. 이 방식을 지속적 통합(CI), 또는 트렁그 기반 개발(TBD)이라 한다. CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들과으 ㅣ차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다.

CI를 적용하기 위해서는 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(기능 플래그 feature flag)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

머지의 복잡도를 줄일 수 있을 뿐만아니라 CI는 리팩터링과도 궁합이 좋다. 켄트 벡이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍(XP)을 만든 이유도 바로 두 기법의 궁합이 잘맞기 때문이다.

기능별 브랜치를 사용하면 안 된다는 말은 아니다. 브랜치를 자주 통합할 수만 있담면 문제가 발생할 가능성을 크게 줄일 수 있다. 실제로 CI를 적용하는 이들도 기능별 브랜치를 많이 사용한다.

### 테스팅

리팩터링으로 인한 오류를 빨리 잡으려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다. 그리고 빠르게 실행할 수 있어야 수시로 테스트하는 데 부담이 없다. 달리 말하면 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다는 뜻이다.

### 레거시 코드

레거시 시스템을 파악할 때 리팩터링이 굉장이 도움된다. 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트하고, 이러한 틈새를 만들 때 리팩터링이 활용된다.

### 데이터베이스

진화형 데이터베이스 설게와 데이터베이스 리팩터링 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.

데이터베이스 리팩터링은 프로덕션 환경에서 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 호나경에서 문제가 생겼을 때 변경을 되돌리기 쉽다.

이를테면 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만하고 사용하지는 않는다. 그런다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 그다음에는 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 이 과정에서 발생하는 버그도 해결함면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 이런 방식은 병렬 수정(또는 팽창-수축)의 일반적인 예다.

### 리팩터링, 아키텍처, 애그니

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.

향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어둔다. 함수를 정의하다보면 범용적으로 사용할 수 잇겠다는 생각이 들 때가 있다. 그래서 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다. 이런 매개변수가 바로 유연성 매커니즘이다. 간혹 함수가 너무 복잡해지는 등 유연성 메커니즘을 잘못 구현할 때도 있다. 요구사항이 변경되는 경우도 있고 이러한 모든 상황을 고려하다 보면 유연성 메커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.

리팩터링을 활용하면 다르게 접근할 수 있다. 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 ㅇ낳고, 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 진행하면서 요구사항을 더 잘 이해하기 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다. 그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유연성 ㅁ메커니즘은 반드시 검증을 거친 후에 추가한다.

이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI(에그니, "You Aren't Gonna Need It(당신은 그것이 필요하지 않을 것이다)"의 줄임말) 등으로 부른다.

## 리팩터링과 소프트웨어 개발 프로세스

XP의 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. 참고로 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 프로그래밍 도중 발생한 오류를 확실히 걸러내느 테스트를 자동으로 수행할 수 있어야 한다. 테스트는 리팩터링에 굉장히 중요한 토대이다.

## 리팩터링 자동화

자동 리팩터링 도구의 등장으로 인텔리제이 IDEA나 이클립스에서 자바로 프로그래밍할 때는 메서드 이름을 바꾸는 작업을 메뉴에서 원하는 항목을 클릭하는 것만으로 처리할 수 있다. 현재는 에디터나 독립 도구에서도 리팩터링 기능을 제공할 정도로 자동 리팩터링이 흔해졌다.

자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다. 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다. 그래서 뛰어난 IDE가 자동 리팩터링도 더 풍부하게 제공하는 경우가 많다. IDE는 리팩터링뿐 아니라 코드 탐색과 린팅을 비롯한 다양한 기능을 구현하는 데 구문 트리를 활용한다.

그런데 단순히 구문 트리를 해석해서 수정하는 것만으로는 리팩터링을 구현할 수 없다. 변경된 구문 트리를 다시 에디터 화면에 텍스트로 바꿔 표현해야 한다. 그래서 리팩터링 기능을 제대로 구현하기란 상당히 어렵다.

최근에는 언어 서버(Language Server)라는 기술이 뜨고 있다. 언어 서버란 구문 트리르 구성해서 텍스트 에디터에 API 형태로 제공하는 소프트웨어다. 언어 서버는 다양한 텍스트 에디터를 지원할 수 잇고, 정교한 코드 분석과 리팩터링 기능을 제공할 수 있다.
