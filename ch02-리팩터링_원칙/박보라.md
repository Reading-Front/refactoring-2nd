# Chapter 02: Principles in Refactoring  
*“원리를 이해해야 제대로 리팩토링할 수 있다”*

## 📖 목차  
1. 리팩토링이란 무엇인가  
2. 두 개의 모자(The Two Hats)  
3. 왜 리팩토링을 해야 하는가  
4. 언제 리팩토링해야 하는가  
5. 리팩토링이 던지는 문제들  
6. 리팩토링과 아키텍처, YAGNI  
7. 리팩토링과 전체 개발 프로세스  
8. 리팩토링과 성능  

---

## 1. 리팩토링이란 무엇인가  
- 리팩토링(명사):  
  > “소프트웨어의 관찰 가능한 동작을 바꾸지 않으면서, 이해하기 쉽고 수정하기 싸게 만들기 위해 내부 구조를 변경하는 것.” :contentReference[oaicite:1]{index=1}  
- 리팩토링(동사):  
  > “관찰 가능한 동작을 바꾸지 않으면서 일련의 리팩토링을 적용해 소프트웨어를 구조화하는 것.” :contentReference[oaicite:2]{index=2}  
- 핵심 포인트: 외부 동작(인터페이스 또는 API)은 변화시키지 않고 내부 구조(코드, 클래스, 메서드)를 깨끗하게 만든다.  
- 이 정의에서 ‘관찰 가능한 동작(observable behaviour)’은 사용자나 다른 모듈이 인지하는 동작을 말하며, 내부 구현이 바뀌어도 결과가 같아야 한다. :contentReference[oaicite:3]{index=3}  

### TypeScript 예시:  
```ts
// 리팩토링 전
class Order {
  constructor(public quantity: number, public itemPrice: number) {}
  getPrice(): number {
    return this.quantity * this.itemPrice;
  }
}

// 리팩토링 후
class Order {
  constructor(private _quantity: number, private _itemPrice: number) {}
  get price(): number {
    return this._quantity * this._itemPrice;
  }
}
````

위 예시에서 외부에서 호출하는 `getPrice()` 메서드가 `price` 게터로 바뀌었지만, 외부에서는 동일한 값을 받아야 한다. 내부 구조를 바꾼 것이다.

---

## 2. 두 개의 모자 (The Two Hats)

* 개발자는 보통 두 가지 ‘모자(hat)’를 번갈아 써야 한다고 한다:

  1. **기능 확장 모자** (Adding functionality) — 새로운 기능을 추가하거나 요구사항을 반영할 때
  2. **리팩토링 모자** (Refactoring) — 기능 변경 없이 코드 내부 구조를 개선할 때
* 이 둘을 동시에 섞으면 안 된다. 즉, 리팩토링을 하는 동안 기능 추가를 하지 말고, 기능 추가를 하는 동안 리팩토링에 몰두하지 않는 것이 좋다. ([ithelp.ithome.com.tw][1])
* 왜냐하면 구조를 변화시키면서 기능을 동시에 변경하면 버그가 들어가기 쉬워지고, 리팩토링 효과도 떨어지기 때문이다.

---

## 3. 왜 리팩토링을 해야 하는가

리팩토링을 해야 할 주요 이유는 다음과 같다:

* **소프트웨어 설계 개선**: 리팩토링을 하지 않으면 내부 설계(아키텍처)가 시간이 지남에 따라 퇴화된다. ([thisprogrammingthing.com][2])
* **코드를 이해하기 쉽게 만든다**: 유지보수와 변화 대응이 쉬워진다. ([ithelp.ithome.com.tw][1])
* **버그를 찾기 쉬워진다**: 내부 구조가 깔끔해지면 잘못된 부분이 드러나기 쉬워진다. ([thisprogrammingthing.com][2])
* **개발 속도를 높일 수 있다**: 초기에는 리팩토링에 시간이 들 수 있지만, 긴 관점에서 보면 변화를 수용하기 쉬운 구조 덕분에 기능 추가나 수정이 빨라진다. ([Recep Inanc | Software Engineer][3])

---

## 4. 언제 리팩토링해야 하는가

* 새로운 기능을 추가하기 전 또는 버그를 수정하기 전에 코드가 복잡하거나 이해하기 어려울 때가 좋은 타이밍이다. ([thisprogrammingthing.com][2])
* 반복되는 코드가 보일 때(“세 번의 법칙(Rule of Three)”: 비슷한 일을 처음엔 그냥 하고, 두 번째도 참지만 고통스럽고, 세 번째 비슷할 때는 리팩토링하라) ([Recep Inanc | Software Engineer][3])
* 코드 리뷰나 페어 프로그래밍 중에 구조가 어지럽다 싶을 때.
* 계획된 리팩토링 시간: 특히 레거시 코드에는 미리 리팩토링을 위한 시간을 마련하는 것이 좋다. ([Recep Inanc | Software Engineer][3])

---

## 5. 리팩토링이 던지는 문제들

* 리팩토링은 결정적이지 않다: 언제 얼마만큼 해야 할지 판단이 필요하다. ([ithelp.ithome.com.tw][1])
* “관찰 가능한 동작을 바꾸지 않는다”는 원칙을 깨트리면 위험하다. 테스트가 없으면 리팩토링은 버그 유입로가 된다. ([GitHub][4])
* 리팩토링만으로는 설계가 좋아지지 않는다; 기능 추가, 아키텍처 변화, 팀 문화 변화와 병행되어야 한다. ([thisprogrammingthing.com][2])
* 성능 최적화와 리팩토링을 혼동하면 안 된다. 리팩토링은 이해하고 수정하기 쉽게 만드는 것이고, 최적화는 성능을 위해 구조를 굽히는 경우가 있다. ([ithelp.ithome.com.tw][1])

---

## 6. 리팩토링과 아키텍처, YAGNI

* 좋은 코드 구조는 리팩토링을 쉽게 만든다. 반대로, 리팩토링이 잘 되는 팀과 프로세스는 “YAGNI(You Aren’t Gonna Need It)” 원칙과 맞물린다: 미래의 기능을 과도하게 고려해 복잡하게 만드는 것보다, 실제 필요한 만큼만 설계하고 자주 리팩토링하는 것이 더 낫다. ([rroggia.github.io][5])
* 아키텍처와 리팩토링은 서로 보완한다: 좋은 아키텍처는 리팩토링을 덜 어렵게 만들고, 리팩토링을 잘 하면 아키텍처가 건강해진다.

---

## 7. 리팩토링과 전체 개발 프로세스

* 리팩토링을 팀 문화와 프로세스에 통합해야 한다: 예컨대 **지속적 통합(Continuous Integration)**, **자동화된 테스트**, **작은 배치 단위(작은 커밋, 짧은 주기)** 등이 리팩토링을 가능하게 한다. ([rroggia.github.io][5])
* “언제든 리팩토링할 준비가 되어 있다”는 상태가 되어야 한다. 그렇지 않으면 ‘언젠가 리팩토링해야지’ → ‘미뤄지다’ 라는 상태에 빠지기 쉽다.

---

## 8. 리팩토링과 성능

* 리팩토링은 **성능 문제 해결**과는 목적이 다르다. 리팩토링은 코드의 내부 품질을 개선하는 것이라면, 성능 최적화는 주로 실행 속도나 메모리 사용량 등을 개선하는 것이다. 혼동하면 “좋은 구조인데 느리다” 혹은 “빠른데 복잡하다”라는 문제에 빠진다. ([ithelp.ithome.com.tw][1])
* 따라서 “먼저 리팩토링하고, 필요하면 성능을 다시 보자”라는 순서가 바람직하다.

---

## ✅ 마무리 요약

* 리팩토링은 **코드의 동작을 바꾸지 않으면서** 내부 구조를 개선하는 과정이다.
* 기능 추가(모자1) ↔ 리팩토링(모자2)를 **구분**해서 수행해야 한다.
* 리팩토링은 단기간에는 비용이 들 수 있지만, 장기적으로는 이해하기 쉬운 코드, 빠른 기능 추가, 적은 버그 수 등이 만들어낸다.
* 팀 프로세스, 테스트, 아키텍처, 문화와 함께 가야 한다.
* 코드가 복잡해지고 바꾸기 어려워졌다면 → 리팩토링 신호이다.
* 성능 최적화보다 **먼저** 코드 구조를 정리하는 것이 올바른 순서다.

---

## 🚀 예시 코드 확장

다음은 리팩토링 원리를 보여주는 조금 더 확장된 예시입니다.

```ts
// 리팩토링 전: 계산 로직이 한 곳에 몰려 있음
type PlayType = "tragedy" | "comedy";

interface Performance {
  playID: string;
  audience: number;
}

interface Play {
  name: string;
  type: PlayType;
}

interface Invoice {
  customer: string;
  performances: Performance[];
}

function statement(invoice: Invoice, plays: Record<string, Play>): string {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `Statement for ${invoice.customer}\n`;

  for (const perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch (play.type) {
      case "tragedy":
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case "comedy":
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 20);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`unknown type: ${play.type}`);
    }

    volumeCredits += Math.max(perf.audience - 30, 0);
    if (play.type === "comedy") volumeCredits += Math.floor(perf.audience / 5);

    result += `  ${play.name}: ${formatUSD(thisAmount / 100)} (${perf.audience} seats)\n`;
    totalAmount += thisAmount;
  }

  result += `Amount owed is ${formatUSD(totalAmount / 100)}\n`;
  result += `You earned ${volumeCredits} credits\n`;
  return result;
}

function formatUSD(amount: number): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2
  }).format(amount);
}

// 리팩토링 후: 계산 로직을 클래스로 분리하고 다형성 적용
class PerformanceCalculator {
  constructor(public performance: Performance, public play: Play) {}

  get amount(): number {
    throw new Error("Subclass responsibility");
  }

  get volumeCredits(): number {
    return Math.max(this.performance.audience - 30, 0);
  }
}

class TragedyCalculator extends PerformanceCalculator {
  get amount(): number {
    let result = 40000;
    if (this.performance.audience > 30) {
      result += 1000 * (this.performance.audience - 30);
    }
    return result;
  }
}

class ComedyCalculator extends PerformanceCalculator {
  get amount(): number {
    let result = 30000;
    if (this.performance.audience > 20) {
      result += 10000 + 500 * (this.performance.audience - 20);
    }
    result += 300 * this.performance.audience;
    return result;
  }

  get volumeCredits(): number {
    return super.volumeCredits + Math.floor(this.performance.audience / 5);
  }
}

function createPerformanceCalculator(perf: Performance, play: Play): PerformanceCalculator {
  switch (play.type) {
    case "tragedy":
      return new TragedyCalculator(perf, play);
    case "comedy":
      return new ComedyCalculator(perf, play);
    default:
      throw new Error(`unknown type: ${play.type}`);
  }
}

function statementRefactored(invoice: Invoice, plays: Record<string, Play>): string {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `Statement for ${invoice.customer}\n`;

  for (const perf of invoice.performances) {
    const play = plays[perf.playID];
    const calculator = createPerformanceCalculator(perf, play);
    result += `  ${play.name}: ${formatUSD(calculator.amount / 100)} (${perf.audience} seats)\n`;
    totalAmount += calculator.amount;
    volumeCredits += calculator.volumeCredits;
  }

  result += `Amount owed is ${formatUSD(totalAmount / 100)}\n`;
  result += `You earned ${volumeCredits} credits\n`;
  return result;
}
```

위 예시에서 보듯이

* 계산 로직이 한 메서드에 뭉쳐 있던 기존 코드를 →
* **다형성과 책임 분리**를 통해 구조화함으로써

  * 이해하기 쉬워지고
  * 수정·확장하기 쉬워진다.
* 이처럼 작은 리팩토링이 전체 코드 품질을 개선하는 데 큰 역할을 한다.
